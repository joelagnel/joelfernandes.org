<!DOCTYPE html>
<html>
<head>
<title>On workings of hrtimer's slack time functionality - Joel Fernandes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="author" content="Joel Fernandes">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="/page.css">
<link rel="stylesheet" href="/css/syntax.css">
<link rel="stylesheet" href="/css/main.css">
</head>
<body>

<div class="page">

<div class="nav">
<p class="navhdr">Joel's site:</p>
<a href="/">Home</a><br>
<a href="/bio.html">Bio</a><br>
<a href="/linuxperf.html">Linux Perf</a><br>
<a href="/rcu.html">RCU</a><br>
<a href="/tracing.html">Tracing</a><br>
<a href="/schedulers.html">Schedulers</a><br>
<a href="/memory-ordering.html">Memory Ordering</a><br>
<a href="/gpu.html">GPU Drivers</a><br>
<a href="/resources/">Talks</a><br>
<a href="/joel/">Resume</a><br>
</div>

<div class="recent">
<p class="navhdr">Recent posts:</p>
<ul>

<li class="recent">2026-02-08 &raquo;<br><a href="/blog/2026-02-08/rust-clist-kernel.html">CList: Iterating C Linked Lists from Rust in the Kernel</a></li>

<li class="recent">2023-06-25 &raquo;<br><a href="/blog/2023-06-25/svm-vectors.html">SVM and vectors for the curious</a></li>

<li class="recent">2023-06-10 &raquo;<br><a href="/blog/2023-06-10/selinux-procfs.html">SELinux Debugging on ChromeOS</a></li>

<li class="recent">2023-04-28 &raquo;<br><a href="/blog/2023-04-28/hazard-pointers.html">Understanding Hazard Pointers</a></li>

<li class="recent">2023-04-25 &raquo;<br><a href="/blog/2023-04-25/ppc-stack-guards.html">PowerPC stack guard false positives in Linux kernel</a></li>

<li class="recent">2023-02-24 &raquo;<br><a href="/blog/2023-02-24/ycm-working.html">Getting YouCompleteMe working for kernel development</a></li>

<li class="recent">2023-01-29 &raquo;<br><a href="/blog/2023-01-29/figuring-out-herd7.html">Figuring out herd7 memory models</a></li>

<li class="recent">2022-12-15 &raquo;<br><a href="/blog/2022-12-15/modeling-condition-variables.html">Modeling Condition Variables using Formal Methods</a></li>

<li class="recent">2022-11-13 &raquo;<br><a href="/blog/2022-11-13/hrtimer.html">On workings of hrtimer's slack time functionality</a></li>

<li class="recent">2020-10-25 &raquo;<br><a href="/blog/2020-10-25/cpp-ref.html">C++ rvalue references</a></li>

</ul>
<p><a href="/">All posts</a><br>
<a href="/bio.html">About</a><br>
<a href="/feed.xml">RSS</a></p>
</div>

<div class="site">

<p><a href="/">&laquo; Back to Home</a></p>

<h1 class="title">On workings of hrtimer's slack time functionality</h1>
<p class="meta">13 Nov 2022</p>

<div class="post">
<p>Below are some notes I wrote while studying hrtimer slack behavior (range
timers), which was added to reduce wakeups and save power, in the commit below.
The idea is that:</p>
<ol>
  <li>Normal hrtimers will have both a soft and hard expiry which are equal to each other.</li>
  <li>But hrtimers with timer slack will have a soft expiry and a hard expiry which is the soft expiry + delta.</li>
</ol>

<p>The slack/delay effect is achieved by splitting the execution of the timer
function, and the programming of the next timer event into 2 separate steps.
That is, we execute the timer function as soon as we notice that its soft
expiry has passed (<code class="language-plaintext highlighter-rouge">hrtimer_run_queues()</code>). However, for programming the next
timer interrupt, we only look at the hard expiry (<code class="language-plaintext highlighter-rouge">hrtimer_update_next_event()</code>
-&gt; <code class="language-plaintext highlighter-rouge">__hrtimer_get_next_event()</code> -&gt;
<code class="language-plaintext highlighter-rouge">__hrtimer_next_event_base()</code>-&gt;<code class="language-plaintext highlighter-rouge">hrtimer_get_expires()</code>). As a result, the only
way a slack-based timer will execute before its slack time elapses, is, if
another timer without any slack time gets queued such that it hard-expires
before the slack time of the slack-based timer passes.</p>

<p>The commit containing the original code added for range timers is:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>commit 654c8e0b1c623b156c5b92f28d914ab38c9c2c90
Author: Arjan van de Ven &lt;arjan@linux.intel.com&gt;
Date:   Mon Sep 1 15:47:08 2008 -0700

    hrtimer: turn hrtimers into range timers
   
    this patch turns hrtimers into range timers;
    they have 2 expire points
    1) the soft expire point
    2) the hard expire point
   
    the kernel will do it's regular best effort attempt to get the timer run at
the hard expire point. However, if some other time fires after the soft expire
point, the kernel now has the freedom to fire this timer at this point, and
thus grouping the events and preventing a power-expensive wakeup in the future.
</code></pre></div></div>
<p>The original code seems a bit buggy. I got a bit confused about how/where we
handle the case in <code class="language-plaintext highlighter-rouge">hrtimer_interrupt()</code> where other normal timers that expire
before the slack time elapses, have their next timer interrupt programmed
correctly such that the interrupt goes off before the slack time passes.</p>

<p>To see the issue, consider the case where we have 2 timers queued:</p>

<ol>
  <li>
    <p>The first one soft expires at t = 10, and say it has a slack of 50, so it hard expires at t = 60.</p>
  </li>
  <li>
    <p>The second one is a normal timer, so the soft/hard expiry of it is both at t = 30.</p>
  </li>
</ol>

<p>Now say, an hrtimer interrupt happens at t=5 courtesy of an unrelated expiring
timer. In the below code, we notice that the next expiring timer is (the one
with slack one), which has not soft-expired yet. So we have no reason to run
it. However, we reprogram the next timer interrupt to be t=60 which is its hard
expiry time (this is stored in expires_next to use as the value to program the
next timer interrupt with).  Now we have a big problem, because the timer
expiring at t=30 will not run in time and run much later.</p>

<p>As shown below, the loop in <code class="language-plaintext highlighter-rouge">hrtimer_interrupt()</code> goes through all the active
timers in the timerqueue, <code class="language-plaintext highlighter-rouge">_softexpires</code> is made to be the real expiry, and the
old <code class="language-plaintext highlighter-rouge">_expires</code> now becomes <code class="language-plaintext highlighter-rouge">_softexpires + slack</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       while((node = timerqueue_getnext(&amp;base-&gt;active))) {
              struct hrtimer *timer;

              timer = container_of(node, struct hrtimer, node);

              /*
               * The immediate goal for using the softexpires is
               * minimizing wakeups, not running timers at the
               * earliest interrupt after their soft expiration.
               * This allows us to avoid using a Priority Search
               * Tree, which can answer a stabbing querry for
               * overlapping intervals and instead use the simple
               * BST we already have.
               * We don't add extra wakeups by delaying timers that
               * are right-of a not yet expired timer, because that
               * timer will have to trigger a wakeup anyway.
               */

              if (basenow.tv64 &lt; hrtimer_get_softexpires_tv64(timer)) {
                      ktime_t expires;

                      expires = ktime_sub(hrtimer_get_expires(timer),
                                          base-&gt;offset);
                      if (expires.tv64 &lt; expires_next.tv64)
                              expires_next = expires;
                      break;
              }

              __run_hrtimer(timer, &amp;basenow);
      }
</code></pre></div></div>
<p>However, this seems to be an old kernel issue, as, in upstream v6.0, I believe
the next hrtimer interrupt will be programmed correctly because
<code class="language-plaintext highlighter-rouge">__hrtimer_next_event_base()</code> calls <code class="language-plaintext highlighter-rouge">hrtimer_get_expires()</code> which correctly use
the “hard expiry” times to do the programming.</p>

</div>

<p><a href="/">&laquo; Back to Home</a></p>

<hr>
<h2>Comments</h2>

<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'linuxinternals1';
    var disqus_identifier = '/blog/2022-11-13/hrtimer.html';
    var disqus_url = 'http://joelfernandes.org/blog/2022-11-13/hrtimer.html';
    
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



<div class="footer">
<div class="contact">
<p>Joel Fernandes · <a href="https://twitter.com/joel_linux">Twitter</a> · <a href="https://www.linkedin.com/in/joelagnel">LinkedIn</a> · <a href="/about-site.html">About site</a></p>
</div>
</div>

</div>

</div>

</body>
</html>
