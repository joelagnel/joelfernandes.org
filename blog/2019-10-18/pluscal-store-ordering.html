<!DOCTYPE html>
<html>
<head>
<title>Modeling (lack of) store ordering using PlusCal - and a wishlist - Joel Fernandes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="author" content="Joel Fernandes">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="/page.css">
<link rel="stylesheet" href="/css/syntax.css">
<link rel="stylesheet" href="/css/main.css">
</head>
<body>

<div class="page">

<div class="nav">
<p class="navhdr">Joel's site:</p>
<a href="/">Home</a><br>
<a href="/bio.html">Bio</a><br>
<a href="/linuxperf.html">Linux Perf</a><br>
<a href="/rcu.html">RCU</a><br>
<a href="/tracing.html">Tracing</a><br>
<a href="/schedulers.html">Schedulers</a><br>
<a href="/memory-ordering.html">Memory Ordering</a><br>
<a href="/gpu.html">GPU Drivers</a><br>
<a href="/resources/">Talks</a><br>
<a href="/personal.html">Personal Posts</a><br>
<a href="/joel/">Resume</a><br>
</div>

<div class="recent">
<p class="navhdr">Recent posts:</p>
<ul>






<li class="recent">2026-02-08 &raquo;<br><a href="/blog/2026-02-08/rust-clist-kernel.html">CList: Iterating C Linked Lists from Rust in the Kernel</a></li>






<li class="recent">2023-06-25 &raquo;<br><a href="/blog/2023-06-25/svm-vectors.html">SVM and vectors for the curious</a></li>






<li class="recent">2023-06-10 &raquo;<br><a href="/blog/2023-06-10/selinux-procfs.html">SELinux Debugging on ChromeOS</a></li>






<li class="recent">2023-04-28 &raquo;<br><a href="/blog/2023-04-28/hazard-pointers.html">Understanding Hazard Pointers</a></li>






<li class="recent">2023-04-25 &raquo;<br><a href="/blog/2023-04-25/ppc-stack-guards.html">PowerPC stack guard false positives in Linux kernel</a></li>






<li class="recent">2023-02-24 &raquo;<br><a href="/blog/2023-02-24/ycm-working.html">Getting YouCompleteMe working for kernel development</a></li>






<li class="recent">2023-01-29 &raquo;<br><a href="/blog/2023-01-29/figuring-out-herd7.html">Figuring out herd7 memory models</a></li>






<li class="recent">2022-12-15 &raquo;<br><a href="/blog/2022-12-15/modeling-condition-variables.html">Modeling Condition Variables using Formal Methods</a></li>






<li class="recent">2022-11-13 &raquo;<br><a href="/blog/2022-11-13/hrtimer.html">On workings of hrtimer's slack time functionality</a></li>






<li class="recent">2020-10-25 &raquo;<br><a href="/blog/2020-10-25/cpp-ref.html">C++ rvalue references</a></li>












































































</ul>

<p class="navhdr">Recent personal:</p>
<ul>




<li class="recent">2026-02-08 &raquo;<br><a href="/blog/2026-02-08/test-post.html">Test Post</a></li>




























































</ul>

<p><a href="/">All posts</a><br>
<a href="/bio.html">About</a><br>
<a href="/feed.xml">RSS</a></p>
</div>

<div class="site">

<p><a href="/">&laquo; Back to Home</a></p>

<h1 class="title">Modeling (lack of) store ordering using PlusCal - and a wishlist</h1>
<p class="meta">18 Oct 2019</p>

<div class="post">
<p>The Message Passing pattern (MP pattern) is shown in the snippet below
(borrowed from LKMM docs). Here, P0 and P1 are 2 CPUs executing some code. P0
stores a message in <code class="language-plaintext highlighter-rouge">buf</code> and then signals to consumers like P1 that the
message is available – by doing a store to <code class="language-plaintext highlighter-rouge">flag</code>. P1 reads <code class="language-plaintext highlighter-rouge">flag</code> and if it
is set, knows that some data is available in <code class="language-plaintext highlighter-rouge">buf</code> and goes ahead and reads it.
However, if <code class="language-plaintext highlighter-rouge">flag</code> is not set, then P1 does nothing else. Without memory
barriers between P0’s stores and P1’s loads, the stores can appear out of order
to P1 (on some systems), thus breaking the pattern. The condition <code class="language-plaintext highlighter-rouge">r1 == 0 and
r2 == 1</code> is a failure in the below code and would violate the condition. Only
after the <code class="language-plaintext highlighter-rouge">flag</code> variable is updated, should P1 be allowed to read the <code class="language-plaintext highlighter-rouge">buf</code>
(“message”).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        int buf = 0, flag = 0;

        P0()
        {
                WRITE_ONCE(buf, 1);
                WRITE_ONCE(flag, 1);
        }

        P1()
        {
                int r1;
                int r2 = 0;

                r1 = READ_ONCE(flag);
                if (r1)
                        r2 = READ_ONCE(buf);
        }
</code></pre></div></div>

<p>Below is a simple program in PlusCal to model the “Message passing” access
pattern and check whether the failure scenario <code class="language-plaintext highlighter-rouge">r1 == 0 and r2 == 1</code> could ever
occur. In PlusCal, we can model the non deterministic out-of-order stores to
<code class="language-plaintext highlighter-rouge">buf</code> and <code class="language-plaintext highlighter-rouge">flag</code> using an <code class="language-plaintext highlighter-rouge">either or</code> block. This makes PlusCal evaluate both
scenarios of stores (store to <code class="language-plaintext highlighter-rouge">buf</code> first and then <code class="language-plaintext highlighter-rouge">flag</code>, or viceversa) during
model checking. The technique used for modeling this non-determinism is similar
to how it is done in Promela/Spin using an “if block” (Refer to Paul McKenney’s
perfbook for details on that).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXTENDS Integers, TLC
(*--algorithm mp_pattern
variables
    buf = 0,
    flag = 0;

process Writer = 1
variables
    begin
e0:
       either
e1:        buf := 1;
e2:        flag := 1;
        or
e3:        flag := 1;
e4:        buf := 1;
        end either;
end process;

process Reader = 2
variables
    r1 = 0,
    r2 = 0;  
    begin
e5:     r1 := flag;
e6:     if r1 = 1 then
e7:         r2 := buf;
        end if;
e8:     assert r1 = 0 \/ r2 = 1;
end process;

end algorithm;*)
</code></pre></div></div>

<p>Sure enough, the <code class="language-plaintext highlighter-rouge">assert r1 = 0 \/ r2 = 1;</code>  fires when the PlusCal program is run through the TLC model checker.</p>

<p>I do find the <code class="language-plaintext highlighter-rouge">either or</code> block clunky, and wish I could just do something like:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>non_deterministic {
        buf := 1;
        flag := 1;
}
</code></pre></div></div>
<p>And then, PlusCal should evaluate both store orders. In fact, if I wanted more than 2 stores, then it can get crazy pretty quickly without such a construct. I should try to hack the PlusCal sources soon if I get time, to do exactly this. Thankfully it is open source software.</p>

<p>Other notes:</p>

<ul>
  <li>
    <p>PlusCal is a powerful language that translates to TLA+. TLA+ is to PlusCal what assembler is to C. I do find PlusCal’s syntax to be non-intuitive but that could just be because I am new to it. In particular, I hate having to mark statements with labels if I don’t want them to atomically execute with neighboring statements. In PlusCal, a label is used to mark a statement as an “atomic” entity. A group of statements under a label are all atomic. However, if you don’t specific labels on every statement like I did above (<code class="language-plaintext highlighter-rouge">eX</code>), then everything goes under a neighboring label. I wish PlusCal had an option, where a programmer could add implict labels to all statements, and then add explicit <code class="language-plaintext highlighter-rouge">atomic { }</code> blocks around statements that were indeed atomic. This is similar to how it is done in Promela/Spin.</p>
  </li>
  <li>
    <p>I might try to hack up my own compiler to TLA+ if I can find the time to, or better yet modify PlusCal itself to do what I want. Thankfully the code for the PlusCal translator is open source software.</p>
  </li>
</ul>

</div>

<p><a href="/">&laquo; Back to Home</a></p>

<hr>
<h2>Comments</h2>
<script src="https://utteranc.es/client.js"
        repo="joelagnel/joelfernandes.org"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


<div class="footer">
<div class="contact">
<p>© Joel Fernandes · <a href="https://twitter.com/joel_linux">Twitter</a> · <a href="https://www.linkedin.com/in/joelagnel">LinkedIn</a> · <a href="/about-site.html">About site</a></p>
</div>
</div>

</div>

</div>

</body>
</html>
