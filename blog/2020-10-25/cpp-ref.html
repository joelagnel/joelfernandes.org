<!DOCTYPE html>
<html>
<head>
<title>C++ rvalue references - Joel Fernandes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="author" content="Joel Fernandes">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="/page.css">
<link rel="stylesheet" href="/css/syntax.css">
<link rel="stylesheet" href="/css/main.css">
</head>
<body>

<div class="page">

<div class="nav">
<p class="navhdr">Joel's site:</p>
<a href="/">Home</a><br>
<a href="/bio.html">Bio</a><br>
<a href="/linuxperf.html">Linux Perf</a><br>
<a href="/rcu.html">RCU</a><br>
<a href="/tracing.html">Tracing</a><br>
<a href="/schedulers.html">Schedulers</a><br>
<a href="/memory-ordering.html">Memory Ordering</a><br>
<a href="/gpu.html">GPU Drivers</a><br>
<a href="/resources/">Talks</a><br>
<a href="/joel/">Resume</a><br>
</div>

<div class="recent">
<p class="navhdr">Recent posts:</p>
<ul>

<li class="recent">2023-06-25 &raquo;<br><a href="/blog/2023-06-25/svm-vectors.html">SVM and vectors for the curious</a></li>

<li class="recent">2023-06-10 &raquo;<br><a href="/blog/2023-06-10/selinux-procfs.html">SELinux Debugging on ChromeOS</a></li>

<li class="recent">2023-04-28 &raquo;<br><a href="/blog/2023-04-28/hazard-pointers.html">Understanding Hazard Pointers</a></li>

<li class="recent">2023-04-25 &raquo;<br><a href="/blog/2023-04-25/ppc-stack-guards.html">PowerPC stack guard false positives in Linux kernel</a></li>

<li class="recent">2023-02-24 &raquo;<br><a href="/blog/2023-02-24/ycm-working.html">Getting YouCompleteMe working for kernel development</a></li>

<li class="recent">2023-01-29 &raquo;<br><a href="/blog/2023-01-29/figuring-out-herd7.html">Figuring out herd7 memory models</a></li>

<li class="recent">2022-11-13 &raquo;<br><a href="/blog/2022-11-13/hrtimer.html">On workings of hrtimer's slack time functionality</a></li>

<li class="recent">2020-10-25 &raquo;<br><a href="/blog/2020-10-25/cpp-ref.html">C++ rvalue references</a></li>

<li class="recent">2020-03-06 &raquo;<br><a href="/blog/2020-03-06/srcu-scan.html">SRCU state double scan</a></li>

<li class="recent">2019-10-18 &raquo;<br><a href="/blog/2019-10-18/pluscal-store-ordering.html">Modeling (lack of) store ordering using PlusCal - and a wishlist</a></li>

</ul>
<p><a href="/">All posts</a><br>
<a href="/bio.html">About</a><br>
<a href="/feed.xml">RSS</a></p>
</div>

<div class="site">

<p><a href="/">&laquo; Back to Home</a></p>

<h1 class="title">C++ rvalue references</h1>
<p class="meta">25 Oct 2020</p>

<div class="post">
<p>The author works in the ChromeOS kernel team, where most of the system
libraries, low-level components and user space is written in C++. Thus the
writer has no choice but to be familiar with C++. It is not that hard, but some
things are confusing. rvalue references are definitely confusing.</p>

<p>In this post, I wish to document rvalue references by simple examples, before I forget it.</p>

<p>Refer to <a href="https://www.chromium.org/rvalue-references">this article</a> for in-depth coverage on rvalue references.</p>

<p>In a nutshell: An rvalue reference can be used to construct a C++ object
efficiently using a “move constructor”. This efficiency is achieved by the
object’s move constructor by <em>moving</em> the underlying memory of the object
efficiently to the destination instead of a full copy. Typically the move
constructor of the object will copy pointers within the source object into the
destination object, and null the pointer within the source object.</p>

<p>An rvalue reference is denoted by a double ampersand (&amp;&amp;) when you want to
create an rvalue reference as a variable.</p>

<p>For example <code class="language-plaintext highlighter-rouge">T &amp;&amp;y;</code> defines a variable y which holds an rvalue reference of
type T. I have almost never seen an rvalue reference variable created this way
in real code. I also have no idea when it can be useful. Almost always they are
created by either of the 2 methods in the next section. These methods create an
“unnamed” rvalue reference which can be passed to a class’s move constructor.</p>

<h2 id="when-is-an-rvalue-reference-created">When is an rvalue reference created?</h2>

<p>In the below example, we create an rvalue reference to a vector, and create
another vector object from this.</p>

<p>This can happen in 2 ways (that I know off):</p>
<h3 id="1-using-stdmove">1. Using std::move</h3>
<p>This converts an lvalue reference to an rvalue reference.</p>

<p>Example:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    int *px, *py;
    std::vector&lt;int&gt; x = {4,3};
    px = &amp;(x[0]);
 
    // Convert lvalue 'x' to rvalue reference and pass
    // it to vector's overloaded move constructor.
    std::vector&lt;int&gt; y(std::move(x)); 
    py = &amp;(y[0]);

    // Confirm the new vector uses same storage
    printf("same vector? : %d\n", px == py); // prints 1
}
</code></pre></div></div>

<h3 id="2-when-returning-something-from-a-function">2. When returning something from a function</h3>
<p>The returned object from the function can be caught as an rvalue reference to that object.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int *pret;
int *py;

std::vector&lt;int&gt; myf(int a)
{
    vector&lt;int&gt; ret;

    ret.push_back(a * a);

    pret = &amp;(ret[0]);

    // Return is caught as an rvalue ref: vector&lt;int&gt; &amp;&amp;
    return ret;
}

int main()
{
    // Invoke vector's move constructor.
    std::vector&lt;int&gt; y(myf(4)); 
    py = &amp;(y[0]);

    // Confirm the vectors share the same underlying storage
    printf("same vector? : %d\n", pret == py); // prints 1
}
</code></pre></div></div>

<h3 id="note-on-move-asssignment">Note on move asssignment</h3>
<p><a href="https://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion-return-statement">Interestingly</a>,
if you construct vector ‘y’ using the assignment operator: <code class="language-plaintext highlighter-rouge">std::vector&lt;int&gt; y
= myf(4);</code>, the compiler may decide to use the move constructor automatically
even though assignment is chosen. I believe this is because of vector’s <a href="https://en.cppreference.com/w/cpp/language/move_assignment">move
assignment operator
overload</a>.</p>

<p>Further, the compiler may even not invoke a constructor at all and just perform
RVO (Return Value Optimization).</p>

<h2 id="quiz">Quiz</h2>
<h4 id="question">Question:</h4>
<p>If I create a named rvalue reference using std::move and then use this to
create a vector, the underlying storage of the new vector is different. Why?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int *pret;
int *py;

std::vector&lt;int&gt; myf(int a)
{
    vector&lt;int&gt; ret;

    ret.push_back(a * a);

    pret = &amp;(ret[0]);

    // Return is caught as an rvalue ref: vector&lt;int&gt; &amp;&amp;
    return ret;
}

int main()
{
    // Invoke vector's move constructor.
    std::vector&lt;int&gt;&amp;&amp; ref = myf(4);
    std::vector&lt;int&gt; y(ref); 
    py = &amp;(y[0]);

    // Confirm the vectors share the same underlying storage
    printf("same vector? : %d\n", pret == py); // prints 0
}
</code></pre></div></div>
<h4 id="answer">Answer</h4>
<p>The answer is: because the value category of the id-expression ‘ref’ is lvalue,
the copy constructor will be chosen. To use the move constructor, it has to be
<code class="language-plaintext highlighter-rouge">std::vector&lt;int&gt; y(std::move(ref));</code>.</p>

<h2 id="conclusion">Conclusion</h2>
<p>rvalue references are confusing and sometimes the compiler can do different
optimizations to cause further confusion. It is best to follow well known
design patterns when designing your code. It may be best to also try to avoid
rvalue references altogether but hopefully this article helps you understand it
a bit more when you come across large C++ code bases.</p>


</div>

<p><a href="/">&laquo; Back to Home</a></p>

<div class="footer">
<div class="contact">
<p>Joel Fernandes · <a href="https://twitter.com/joel_linux">Twitter</a> · <a href="https://www.linkedin.com/in/joelagnel">LinkedIn</a> · <a href="/about-site.html">About site</a></p>
</div>
</div>

</div>

</div>

</body>
</html>
