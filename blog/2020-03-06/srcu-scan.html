<!DOCTYPE html>
<html>
<head>
<title>SRCU state double scan - Joel Fernandes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="author" content="Joel Fernandes">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="/page.css">
<link rel="stylesheet" href="/css/syntax.css">
<link rel="stylesheet" href="/css/main.css">
</head>
<body>

<div class="page">

<div class="nav">
<p class="navhdr">Joel's site:</p>
<a href="/">Home</a><br>
<a href="/bio.html">Bio</a><br>
<a href="/linuxperf.html">Linux Perf</a><br>
<a href="/rcu.html">RCU</a><br>
<a href="/tracing.html">Tracing</a><br>
<a href="/schedulers.html">Schedulers</a><br>
<a href="/memory-ordering.html">Memory Ordering</a><br>
<a href="/gpu.html">GPU Drivers</a><br>
<a href="/resources/">Talks</a><br>
<a href="/joel/">Resume</a><br>
</div>

<div class="recent">
<p class="navhdr">Recent posts:</p>
<ul>

<li class="recent">2026-02-08 &raquo;<br><a href="/blog/2026-02-08/rust-clist-kernel.html">CList: Iterating C Linked Lists from Rust in the Kernel</a></li>

<li class="recent">2023-06-25 &raquo;<br><a href="/blog/2023-06-25/svm-vectors.html">SVM and vectors for the curious</a></li>

<li class="recent">2023-06-10 &raquo;<br><a href="/blog/2023-06-10/selinux-procfs.html">SELinux Debugging on ChromeOS</a></li>

<li class="recent">2023-04-28 &raquo;<br><a href="/blog/2023-04-28/hazard-pointers.html">Understanding Hazard Pointers</a></li>

<li class="recent">2023-04-25 &raquo;<br><a href="/blog/2023-04-25/ppc-stack-guards.html">PowerPC stack guard false positives in Linux kernel</a></li>

<li class="recent">2023-02-24 &raquo;<br><a href="/blog/2023-02-24/ycm-working.html">Getting YouCompleteMe working for kernel development</a></li>

<li class="recent">2023-01-29 &raquo;<br><a href="/blog/2023-01-29/figuring-out-herd7.html">Figuring out herd7 memory models</a></li>

<li class="recent">2022-12-15 &raquo;<br><a href="/blog/2022-12-15/modeling-condition-variables.html">Modeling Condition Variables using Formal Methods</a></li>

<li class="recent">2022-11-13 &raquo;<br><a href="/blog/2022-11-13/hrtimer.html">On workings of hrtimer's slack time functionality</a></li>

<li class="recent">2020-10-25 &raquo;<br><a href="/blog/2020-10-25/cpp-ref.html">C++ rvalue references</a></li>

</ul>
<p><a href="/">All posts</a><br>
<a href="/bio.html">About</a><br>
<a href="/feed.xml">RSS</a></p>
</div>

<div class="site">

<p><a href="/">&laquo; Back to Home</a></p>

<h1 class="title">SRCU state double scan</h1>
<p class="meta">06 Mar 2020</p>

<div class="post">
<p>The SRCU flavor of RCU uses per-cpu counters to detect that every CPU has
passed through a quiescent state for a particular SRCU lock instance
(<code class="language-plaintext highlighter-rouge">srcu_struct</code>).</p>

<p>There’s are total of 4 counters per-cpu. One pair for locks, and another for
unlocks. You can think of the SRCU instance to be split into 2 parts. The
readers sample <code class="language-plaintext highlighter-rouge">srcu_idx</code> and decided which part to use. Each part corresponds
to one pair of lock and unlock counters. A reader increments a part’s lock
counter during locking and likewise for unlock.</p>

<p>During an update, the updater flips <code class="language-plaintext highlighter-rouge">srcu_idx</code> (thus attempting to force new
readers to use the other part) and waits for the lock/unlock counters on the
previous value of <code class="language-plaintext highlighter-rouge">srcu_idx</code> to match.  Once the sum of the lock counters of
all CPUs match that of unlock, the system knows all pre-existing read-side
critical sections have completed.</p>

<p>Things are not that simple, however. It is possible that a reader samples the
<code class="language-plaintext highlighter-rouge">srcu_idx</code>, but before it can increment the lock counter corresponding to it,
it undergoes a long delay. We thus we end up in a situation where there are
readers in both <code class="language-plaintext highlighter-rouge">srcu_idx = 0</code> and <code class="language-plaintext highlighter-rouge">srcu_idx = 1</code>.</p>

<p>To prevent such a situation, a writer has to wait for readers corresponding to
both <code class="language-plaintext highlighter-rouge">srcu_idx = 0</code> and <code class="language-plaintext highlighter-rouge">srcu_idx = 1</code> to complete. This depicted with ‘A MUST’
in the below pseudo-code:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        reader 1        writer                        reader 2
        -------------------------------------------------------
        // read_lock
        // enter
        Read: idx = 0;
        &lt;long delay&gt;    // write_lock
                        // enter
                        wait_for lock[1]==unlock[1]
                        idx = 1; /* flip */
                        wait_for lock[0]==unlock[0]
                        done.
                                                      Read: idx = 1;
        lock[0]++;
                                                      lock[1]++;
                        // write_lock
                        // return
        // read_lock
        // return
        /**** NOW BOTH lock[0] and lock[1] are non-zero!! ****/
                        // write_lock
                        // enter
                        wait_for lock[0]==unlock[0] &lt;- A MUST!
                        idx = 0; /* flip */
                        wait_for lock[1]==unlock[1] &lt;- A MUST!
</code></pre></div></div>
<p>NOTE: QRCU has a similar issue. However it overcomes such a race in the reader
by retrying the sampling of its <code class="language-plaintext highlighter-rouge">srcu_idx</code> equivalent.</p>

<p>Q: If you have to wait for readers of both <code class="language-plaintext highlighter-rouge">srcu_idx = 0</code>, and <code class="language-plaintext highlighter-rouge">1</code>, then why
not just have a single counter and do away with the “flipping” logic?</p>

<p>Ans:
Because of updater forward progress. If we had a single counter, then it is
possible that new readers would constantly increment the lock counter, thus
updaters would be waiting all the time. By using the ‘flip’ logic, we are able
to drain pre-existing readers using the inactive part of <code class="language-plaintext highlighter-rouge">srcu_idx</code> to be
drained in a bounded time. The number of readers of a ‘flipped’ part would only
monotonically decrease since new readers go to its counterpart.</p>

<p>2023 update:
I have more detailed notes with diagrams and such on this and other cases. Just
reach out to me if you want to take a look at those.</p>

</div>

<p><a href="/">&laquo; Back to Home</a></p>

<hr>
<h2>Comments</h2>

<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'linuxinternals1';
    var disqus_identifier = '/blog/2020-03-06/srcu-scan.html';
    var disqus_url = 'http://joelfernandes.org/blog/2020-03-06/srcu-scan.html';
    
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



<div class="footer">
<div class="contact">
<p>Joel Fernandes · <a href="https://twitter.com/joel_linux">Twitter</a> · <a href="https://www.linkedin.com/in/joelagnel">LinkedIn</a> · <a href="/about-site.html">About site</a></p>
</div>
</div>

</div>

</div>

</body>
</html>
