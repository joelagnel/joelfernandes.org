<!DOCTYPE html>
<html>
<head>
<title>GUS (Global Unbounded Sequences) - Joel Fernandes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="author" content="Joel Fernandes">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="/page.css">
<link rel="stylesheet" href="/css/syntax.css">
<link rel="stylesheet" href="/css/main.css">
</head>
<body>

<div class="page">

<div class="nav">
<p class="navhdr">Joel's site:</p>
<a href="/">Home</a><br>
<a href="/joel/">Resume</a><br>
<a href="/technical.html">Technical Posts</a><br>
<a href="/personal.html">Personal Posts</a><br>
</div>

<div class="recent">
<p class="navhdr">Recent technical posts:</p>
<ul>






<li class="recent">2026-02-08 &raquo;<br><a href="/blog/2026-02-08/rust-clist-kernel.html">CList: Iterating C Linked Lists from Rust in the Kernel</a></li>






<li class="recent">2023-06-25 &raquo;<br><a href="/blog/2023-06-25/svm-vectors.html">SVM and vectors for the curious</a></li>






<li class="recent">2023-06-10 &raquo;<br><a href="/blog/2023-06-10/selinux-procfs.html">SELinux Debugging on ChromeOS</a></li>






<li class="recent">2023-04-28 &raquo;<br><a href="/blog/2023-04-28/hazard-pointers.html">Understanding Hazard Pointers</a></li>






<li class="recent">2023-04-25 &raquo;<br><a href="/blog/2023-04-25/ppc-stack-guards.html">PowerPC stack guard false positives in Linux kernel</a></li>






<li class="recent">2023-02-24 &raquo;<br><a href="/blog/2023-02-24/ycm-working.html">Getting YouCompleteMe working for kernel development</a></li>






<li class="recent">2023-01-29 &raquo;<br><a href="/blog/2023-01-29/figuring-out-herd7.html">Figuring out herd7 memory models</a></li>






<li class="recent">2022-12-15 &raquo;<br><a href="/blog/2022-12-15/modeling-condition-variables.html">Modeling Condition Variables using Formal Methods</a></li>






<li class="recent">2022-11-13 &raquo;<br><a href="/blog/2022-11-13/hrtimer.html">On workings of hrtimer's slack time functionality</a></li>






<li class="recent">2020-10-25 &raquo;<br><a href="/blog/2020-10-25/cpp-ref.html">C++ rvalue references</a></li>












































































</ul>

<hr>

<p class="navhdr">Recent personal posts:</p>
<ul>




<li class="recent">2026-02-08 &raquo;<br><a href="/blog/2026-02-08/test-post.html">New York City</a></li>




























































</ul>

<hr>

<p><a href="/technical.html">All technical posts</a><br>
<a href="/personal.html">All personal posts</a></p>
</div>

<div class="site">

<p><a href="/">&laquo; Back to Home</a></p>

<h1 class="title">GUS (Global Unbounded Sequences)</h1>
<p class="meta">24 Apr 2020</p>

<div class="post">
<p>GUS is a memory reclaim algorithm used in FreeBSD, similar to RCU. It is
borrows concepts from Epoch and Parsec. A video of a presentation describing
the integration of GUS with UMA (FreeBSD’s slab implementation) is here:
https://www.youtube.com/watch?v=ZXUIFj4nRjk</p>

<p>The best description of GUS is in the FreeBSD code
<a href="http://bxr.su/FreeBSD/sys/kern/subr_smr.c#44">itself</a>. It is based on the
concept of global write clock, with readers catching up to writers.</p>

<p>Effectively, I see GUS as an implementation of light traveling from distant
stars. When a photon leaves a star, it is no longer needed by the star and is
ready to be reclaimed. However, on earth we can’t see the photon yet, we can
only see what we’ve been shown so far, and in a way, if we’ve not seen
something because enough “time” has not passed, then we may not reclaim it yet.
If we’ve not seen something, we will see it at some point in the future. Till
then we need to sit tight.</p>

<p>Roughly, an implementation has 2+N counters (with N CPUs):</p>
<ol>
  <li>Global write sequence.</li>
  <li>Global read sequence.</li>
  <li>Per-cpu read sequence (read from #1 when a reader starts)</li>
</ol>

<p>On freeing, the object is tagged with the write sequence. Only once global read
sequence has caught up with global write sequence, the object is freed. Until
then, the free’ing is deferred. The <code class="language-plaintext highlighter-rouge">poll()</code> operation updates #2 by referring
to #3 of all CPUs.  Whatever was tagged between the old read sequence and new
read sequence can be freed. This is similar to <code class="language-plaintext highlighter-rouge">synchronize_rcu()</code> in the Linux
kernel which waits for all readers to have finished observing the object being
reclaimed.</p>

<p>Note the scalability drawbacks of this reclaim scheme:</p>

<ol>
  <li>
    <p>Expensive poll operation if you have 1000s of CPUs.  (Note: Parsec uses a
tree-based mechanism to improve the situation which GUS could consider)</p>
  </li>
  <li>
    <p>Heavy-weight memory barriers are needed (SRCU has a similar drawback) to
ensure ordering properties of reader sections with respect to poll() operation.</p>
  </li>
  <li>
    <p>There can be a delay between reading the global write-sequence number and
writing it into the per-cpu read-sequence number. This can cause the per-cpu
read-sequence to advance past the global write-sequence. Special handling is
needed.</p>
  </li>
</ol>

<p>One advantage of the scheme could be implementation simplicity.</p>

<p>RCU (not SRCU or Userspace RCU) doesn’t suffer from these drawbacks.
Reader-sections in Linux kernel RCU are extremely scalable and lightweight.</p>

</div>

<p><a href="/">&laquo; Back to Home</a></p>

<hr>
<h2>Comments</h2>
<script src="https://utteranc.es/client.js"
        repo="joelagnel/joelfernandes.org"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


<div class="footer">
<div class="contact">
<p>© Joel Fernandes · <a href="https://twitter.com/joel_linux">Twitter</a> · <a href="https://www.linkedin.com/in/joelagnel">LinkedIn</a> · <a href="/about-site.html">About site</a></p>
</div>
</div>

</div>

</div>

</body>
</html>
