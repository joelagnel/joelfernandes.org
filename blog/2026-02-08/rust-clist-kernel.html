<!DOCTYPE html>
<html>
<head>
<title>CList: Iterating C Linked Lists from Rust in the Kernel - Joel Fernandes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="author" content="Joel Fernandes">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="/page.css">
<link rel="stylesheet" href="/css/syntax.css">
<link rel="stylesheet" href="/css/main.css">
</head>
<body>

<div class="page">

<div class="nav">
<p class="navhdr">Joel's site:</p>
<a href="/">Home</a><br>
<a href="/joel/">Resume</a><br>
<a href="/technical.html">Technical Posts</a><br>
<a href="/personal.html">Personal Posts</a><br>
</div>

<div class="recent">
<p class="navhdr">Recent technical posts:</p>
<ul>






<li class="recent">2026-02-08 &raquo;<br><a href="/blog/2026-02-08/rust-clist-kernel.html">CList: Iterating C Linked Lists from Rust in the Kernel</a></li>






<li class="recent">2023-06-25 &raquo;<br><a href="/blog/2023-06-25/svm-vectors.html">SVM and vectors for the curious</a></li>






<li class="recent">2023-06-10 &raquo;<br><a href="/blog/2023-06-10/selinux-procfs.html">SELinux Debugging on ChromeOS</a></li>






<li class="recent">2023-04-28 &raquo;<br><a href="/blog/2023-04-28/hazard-pointers.html">Understanding Hazard Pointers</a></li>






<li class="recent">2023-04-25 &raquo;<br><a href="/blog/2023-04-25/ppc-stack-guards.html">PowerPC stack guard false positives in Linux kernel</a></li>






<li class="recent">2023-02-24 &raquo;<br><a href="/blog/2023-02-24/ycm-working.html">Getting YouCompleteMe working for kernel development</a></li>






<li class="recent">2023-01-29 &raquo;<br><a href="/blog/2023-01-29/figuring-out-herd7.html">Figuring out herd7 memory models</a></li>






<li class="recent">2022-12-15 &raquo;<br><a href="/blog/2022-12-15/modeling-condition-variables.html">Modeling Condition Variables using Formal Methods</a></li>






<li class="recent">2022-11-13 &raquo;<br><a href="/blog/2022-11-13/hrtimer.html">On workings of hrtimer's slack time functionality</a></li>






<li class="recent">2020-10-25 &raquo;<br><a href="/blog/2020-10-25/cpp-ref.html">C++ rvalue references</a></li>












































































</ul>

<hr>

<p class="navhdr">Recent personal posts:</p>
<ul>




<li class="recent">2026-02-08 &raquo;<br><a href="/blog/2026-02-08/test-post.html">Test Post</a></li>




























































</ul>

<hr>

<p><a href="/technical.html">All technical posts</a><br>
<a href="/personal.html">All personal posts</a></p>
</div>

<div class="site">

<p><a href="/">&laquo; Back to Home</a></p>

<h1 class="title">CList: Iterating C Linked Lists from Rust in the Kernel</h1>
<p class="meta">08 Feb 2026</p>

<div class="post">
<p>The Linux kernel’s doubly-circular linked list (<code class="language-plaintext highlighter-rouge">struct list_head</code>) is quite common. When writing Rust code that interfaces with C subsystems, we need a way to iterate over these lists safely. This post explains CList, a Rust abstraction for C linked lists I am <a href="https://lore.kernel.org/all/20260120204303.3229303-1-joelagnelf@nvidia.com/">proposing</a> that uses const generics to create a new dynamic type (a feature similar to C++ <a href="https://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter">non-type template parameters</a>).</p>

<h2 id="the-problem">The Problem</h2>

<p>Rust in the kernel already has <a href="https://github.com/torvalds/linux/blob/master/rust/kernel/list.rs">linked list abstractions</a>, but they don’t fit into the ownership model we need for interfacing with linked lists created by C. When C code creates and manages a linked list, Rust code can’t claim ownership - it can only borrow and iterate. The existing Rust list types assume Rust owns the nodes, which doesn’t work when interfacing with C.</p>

<p>My use case is the GPU buddy allocator: C code allocates memory blocks and links them together. Rust driver code needs to iterate over those blocks without taking ownership or modifying the list structure.</p>

<h2 id="the-container_of-pattern-in-c">The container_of Pattern in C</h2>

<p>C’s <code class="language-plaintext highlighter-rouge">list_for_each_entry</code> macro uses <code class="language-plaintext highlighter-rouge">container_of</code> to convert a <code class="language-plaintext highlighter-rouge">list_head</code> pointer to a pointer to the containing structure:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define container_of(ptr, type, member) \
    ((type *)((char *)(ptr) - offsetof(type, member)))
</span></code></pre></div></div>

<p>This requires knowing the byte offset of the <code class="language-plaintext highlighter-rouge">list_head</code> field within the containing struct. In Rust, we can compute this at compile time with <code class="language-plaintext highlighter-rouge">offset_of!</code> and propagate it through the type system using const generics. Unlike with C, we can do this once when we define the CList type dynamically and don’t have to do it every time we iterate!</p>

<h2 id="const-generic-offset-technique">Const Generic Offset Technique</h2>

<p>The <code class="language-plaintext highlighter-rouge">CList</code> type carries the offset as a const generic parameter:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">CList</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">OFFSET</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">head</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">CListHead</span><span class="p">,</span>
    <span class="n">_phantom</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you create a <code class="language-plaintext highlighter-rouge">CList</code>, the <code class="language-plaintext highlighter-rouge">clist_create!</code> macro computes the offset and bakes it into the type at compile time:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">clist_create</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$head:expr</span><span class="p">,</span> <span class="nv">$rust_type:ty</span><span class="p">,</span> <span class="nv">$c_type:ty</span><span class="p">,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$field:tt</span><span class="p">)</span>.<span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{{</span>
        <span class="k">const</span> <span class="n">OFFSET</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="p">::</span><span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nd">offset_of!</span><span class="p">(</span><span class="nv">$c_type</span><span class="p">,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$field</span><span class="p">)</span>.<span class="o">+</span><span class="p">);</span>
        <span class="nv">$crate</span><span class="p">::</span><span class="nn">clist</span><span class="p">::</span><span class="nn">CList</span><span class="p">::</span><span class="o">&lt;</span><span class="nv">$rust_type</span><span class="p">,</span> <span class="n">OFFSET</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nv">$head</span><span class="p">)</span>
    <span class="p">}};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Your new dynamic CList type can also provide a custom iterator. No need to call container_of every time (and say a prayer you got the offset right!).</p>

<p>First, your generic CList type creates a new generic iterator using the same const generic:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">OFFSET</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">CList</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">OFFSET</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">CListIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">OFFSET</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">CListIter</span> <span class="p">{</span>
            <span class="n">head_iter</span><span class="p">:</span> <span class="n">CListHeadIter</span> <span class="p">{</span>
                <span class="n">current_head</span><span class="p">:</span> <span class="k">self</span><span class="py">.head</span><span class="p">,</span>
                <span class="n">list_head</span><span class="p">:</span> <span class="k">self</span><span class="py">.head</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">_phantom</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then every time you iterate, it uses OFFSET to perform the container_of equivalent:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">OFFSET</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="n">CListIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">OFFSET</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">head</span> <span class="o">=</span> <span class="k">self</span><span class="py">.head_iter</span><span class="nf">.next</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="c1">// The const generic OFFSET is used here to compute the item pointer</span>
        <span class="nf">Some</span><span class="p">(</span><span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="n">head</span><span class="nf">.as_raw</span><span class="p">()</span><span class="nf">.byte_sub</span><span class="p">(</span><span class="n">OFFSET</span><span class="p">)</span><span class="py">.cast</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="why-const-generics-matter">Why Const Generics Matter</h2>

<p>The offset is computed once at compile time and baked into the type. Type safety: you can’t accidentally use the wrong offset due to bugs in your iterator body. The iterator created for you automatically does it. This is a key Rust principle - some problems can be moved into the type system in a way that reduces programmer bugs by not having to write code that might be error prone.</p>

<h2 id="usage-example">Usage Example</h2>

<p>This is how I am using it in Rust in the kernel. A clist_create macro is provided which automatically does the creation of the CList. You just have to pass it the container type and it’ll do the rest. The CList creation macro is defined as follows. It just needs to know the C and Rust container types, a pointer to the head of the list, and the name of the list_head field:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">clist_create!</span><span class="p">(</span><span class="n">head_ptr</span><span class="p">,</span> <span class="n">RustType</span><span class="p">,</span> <span class="n">CType</span><span class="p">,</span> <span class="n">link_field</span><span class="p">)</span>
</code></pre></div></div>

<p>And here is the full real world example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C struct with embedded list_head (from gpu_buddy allocator)</span>
<span class="nd">#[repr(C)]</span>
<span class="k">struct</span> <span class="n">gpu_buddy_block</span> <span class="p">{</span>
    <span class="n">link</span><span class="p">:</span> <span class="nn">bindings</span><span class="p">::</span><span class="n">list_head</span><span class="p">,</span>
    <span class="c1">// ... other fields</span>
<span class="p">}</span>

<span class="c1">// Rust wrapper</span>
<span class="nd">#[repr(transparent)]</span>
<span class="k">struct</span> <span class="nf">Block</span><span class="p">(</span><span class="n">Opaque</span><span class="o">&lt;</span><span class="n">gpu_buddy_block</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// AllocatedBlocks holds a CListHead that C code populates</span>
<span class="k">struct</span> <span class="n">AllocatedBlocks</span> <span class="p">{</span>
    <span class="n">list</span><span class="p">:</span> <span class="n">CListHead</span><span class="p">,</span>
    <span class="n">buddy</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">GpuBuddy</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Iterate over blocks from C-allocated list</span>
<span class="k">let</span> <span class="n">list</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nd">clist_create!</span><span class="p">(</span><span class="n">allocated</span><span class="py">.list</span><span class="nf">.as_raw</span><span class="p">(),</span> <span class="n">Block</span><span class="p">,</span> <span class="n">gpu_buddy_block</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">};</span>
<span class="k">for</span> <span class="n">block</span> <span class="k">in</span> <span class="n">list</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// process each block</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="design-constraints">Design Constraints</h2>

<p>The current implementation is read-only. Mutable iteration would require more complex safety reasoning. C code must not modify the list while Rust is iterating.</p>

<p>That’s by design. For nova-core’s memory management, we just need to iterate over buddy allocator blocks that C code creates. Mutation can come later with more careful ownership work. Perhaps we can also make this new module play well with the existing list.rs code.</p>

<h2 id="review-feedback">Review Feedback</h2>

<p>The review feedback has been positive. Special thanks to Alice Ryhl, Alexandre Courbot, Gary Guo, and Zhi Wang who shaped this work. I am also particularly impressed by the speed of review from the Linux kernel Rust community. They are quite dedicated to this project and that is quite refreshing to see.</p>

<h2 id="whats-next">What’s Next</h2>

<p>CList is part of a <a href="https://lore.kernel.org/all/20260120204303.3229303-1-joelagnelf@nvidia.com/">larger memory management infrastructure</a> for the nova-core GPU driver that I am working on. Quite exciting and it’s coming together nicely: GPU buddy allocator, page tables, virtual memory management, and more. See the RFC v6 patches for the full implementation.</p>

</div>

<p><a href="/">&laquo; Back to Home</a></p>

<hr>
<h2>Comments</h2>
<script src="https://utteranc.es/client.js"
        repo="joelagnel/joelfernandes.org"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


<div class="footer">
<div class="contact">
<p>© Joel Fernandes · <a href="https://twitter.com/joel_linux">Twitter</a> · <a href="https://www.linkedin.com/in/joelagnel">LinkedIn</a> · <a href="/about-site.html">About site</a></p>
</div>
</div>

</div>

</div>

</body>
</html>
