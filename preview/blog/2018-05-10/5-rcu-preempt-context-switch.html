<!DOCTYPE html>
<html>
<head>
<title>RCU-preempt: What happens on a context switch - Joel Fernandes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="author" content="Joel Fernandes">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="/css/syntax.css">
<link rel="stylesheet" href="/css/main.css">
</head>
<body>

<div class="page">

<div class="nav">
<p class="navhdr">Joel's site:</p>
<a href="/">Home</a><br>
<a href="/bio.html">Bio</a><br>
<a href="/linuxperf.html">Linux Perf</a><br>
<a href="/rcu.html">RCU</a><br>
<a href="/tracing.html">Tracing</a><br>
<a href="/schedulers.html">Schedulers</a><br>
<a href="/memory-ordering.html">Memory Ordering</a><br>
<a href="/gpu.html">GPU Drivers</a><br>
<a href="/resources/">Talks</a><br>
<a href="/joel/">Resume</a><br>
</div>

<div class="recent">
<p class="navhdr">Recent posts:</p>
<ul>

<li class="recent">2023-06-25 &raquo;<br><a href="/blog/2023-06-25/svm-vectors.html">SVM and vectors for the curious</a></li>

<li class="recent">2023-06-10 &raquo;<br><a href="/blog/2023-06-10/selinux-procfs.html">SELinux Debugging on ChromeOS</a></li>

<li class="recent">2023-04-28 &raquo;<br><a href="/blog/2023-04-28/hazard-pointers.html">Understanding Hazard Pointers</a></li>

<li class="recent">2023-04-25 &raquo;<br><a href="/blog/2023-04-25/ppc-stack-guards.html">PowerPC stack guard false positives in Linux kernel</a></li>

<li class="recent">2023-02-24 &raquo;<br><a href="/blog/2023-02-24/ycm-working.html">Getting YouCompleteMe working for kernel development</a></li>

<li class="recent">2023-01-29 &raquo;<br><a href="/blog/2023-01-29/figuring-out-herd7.html">Figuring out herd7 memory models</a></li>

<li class="recent">2022-11-13 &raquo;<br><a href="/blog/2022-11-13/hrtimer.html">On workings of hrtimer's slack time functionality</a></li>

<li class="recent">2020-10-25 &raquo;<br><a href="/blog/2020-10-25/cpp-ref.html">C++ rvalue references</a></li>

<li class="recent">2020-03-06 &raquo;<br><a href="/blog/2020-03-06/srcu-scan.html">SRCU state double scan</a></li>

<li class="recent">2019-10-18 &raquo;<br><a href="/blog/2019-10-18/pluscal-store-ordering.html">Modeling (lack of) store ordering using PlusCal - and a wishlist</a></li>

</ul>
<p><a href="/">All posts</a><br>
<a href="/bio.html">About</a><br>
<a href="/feed.xml">RSS</a></p>
</div>

<div class="site">

<p><a href="/">&laquo; Back to Home</a></p>

<h1 class="title">RCU-preempt: What happens on a context switch</h1>
<p class="meta">10 May 2018</p>

<div class="post">
<p>Note: This article requires knowledge of RCU (read copy update) basics and its
different flavors.</p>

<p>RCU’s main algorithm is to detect when it is free to reclaim objects that RCU
readers no longer need. The “RCU-sched” flavor of RCU does this by just
disabling preemption across the read section. So any time any of the CPUs is
not running in a preempt disabled section (such as with preemption off, or
interrupts off), then the CPU is said to be in a “quiescent state” (QS). Once
all CPUs reach a QS after the reclaimer filed a claim to release an object, the
object can be safely released. The time from when the request for RCU to
release an object to when RCU says its Ok to release it, is called the grace
period.</p>

<p>RCU-sched is kind of a big hammer, having readers disable preemption can have
poor performance effects. After all, read sections are expected to be light in
RCU. It can also effect real-time response of applications.</p>

<p>For this reason, preemptible RCU came about (also called RCU-preempt).
Obviously in this flavor, RCU reader sections can get preempted to run
something else.</p>

<p>A <a href="https://www.mail-archive.com/linux-kernel@vger.kernel.org/msg1682346.html">recent discussion</a>
on LKML clarified to me that “preempted to run something else” not only covers
involuntary preemption but also voluntarily sleeping. This design is because,
with <code class="language-plaintext highlighter-rouge">PREEMPT_RT</code> kernels, “rt” version of spinlocks are actually mutexes that
can put the RCU reader to sleep.</p>

<p>So coming back to the point of this article, I want to go over what happens on
a context-switch. When the scheduler is called, we end up in <code class="language-plaintext highlighter-rouge">__schedule</code>
function. Here in the beginning <code class="language-plaintext highlighter-rouge">rcu_note_context_switch</code> is called with the
<code class="language-plaintext highlighter-rouge">preempt</code> parameter. The <code class="language-plaintext highlighter-rouge">preempt</code> parameter indicates if task blocked with
help of <code class="language-plaintext highlighter-rouge">schedule()</code> or if it was a kernel path (such as return from interrupts
or system calls) that called into the scheduler to preempt the currently
running task.</p>

<p><code class="language-plaintext highlighter-rouge">rcu_note_context_switch</code> first calls <code class="language-plaintext highlighter-rouge">rcu_preempt_note_context_switch</code> for
RCU-preempt to take note. Lets discuss this function.</p>

<p>First note that the RCU-preempt flavor does warn you if you voluntarily sleep inside
an RCU read side section. I’m not sure how the “RT-spinlock” for RT kernels
doesn’t get this warning. Probably they delete this warning in PREEMPT_RT
patchset, idk. The warning is <code class="language-plaintext highlighter-rouge">WARN_ON_ONCE(!preempt &amp;&amp;
t-&gt;rcu_read_lock_nesting &gt; 0);</code>. But seems pretty clear to me a non-RT kernel
would scream with this warning if an RCU-preempt read section went to sleep.
Getting preempted is Ok but not voluntary sleeping according to this code! (see
side note in last para)</p>

<p>If the task being preempted is in a read-side RCU section, then (and only then)
it calls <code class="language-plaintext highlighter-rouge">rcu_preempt_ctxt_queue</code>. Here the task being preempted is added to a
list of blocked tasks. The reason why we need to add it is, RCU-preempt has 2
perspectives of Quiescent state (QS). Recall, a QS is reached whenever an
entity is not blocking the current grace period (GP). RCU-preempt considers 2
entity perspectives: Either the task, or the CPU. In the RCU-preempt world, if
a task that is currently in an RCU read section gets preempted, then the CPU
has reached a QS because it is no longer running the RCU-read section that is
blocking the GP. But now, the task has reached a non-QS (It is blocking the
GP). This list basically indicates this fact. If there are blocking tasks, then
the GP cannot complete even though the CPU reports its QS. <a href="https://lkml.org/lkml/2018/5/4/632">Paul Mckenney explains this here</a>. The other benefit of having a list of tasks is that preempted RCU read sections can be boosted. Paul Mckenney again came to the rescue to <a href="https://lkml.org/lkml/2018/5/4/659">explain this to me</a>.</p>

<p>Finally, you see that <code class="language-plaintext highlighter-rouge">rcu_preempt_note_context_switch</code> does report a QS. This
is because if the task was in a read section, it has just been added to the
blocked task list. If its not, then we just reached a QS for the CPU. Either
way we entered a CPU QS. So is recorded with a call to <code class="language-plaintext highlighter-rouge">rcu_preempt_qs();</code>.</p>

<p>Please go through the <a href="https://www.kernel.org/doc/Documentation/RCU/Design/Expedited-Grace-Periods/Expedited-Grace-Periods.html">Expedited GP document</a> which also explains some of the RCU-preempt behaviors.</p>

<p>Side note: At the moment, I don’t immediately see why by blocking in a RCU-preempt
section shouldn’t be allowed.  Since we’re tracking blocked tasks the same way
as preempted tasks, it should be possible to handle them the same way. They
both cause a CPU QS and a task non-QS to be entered, they both need priority
boosting. Perhaps the warning should be removed? Let me know your feedback in
the comments.</p>

</div>

<p><a href="/">&laquo; Back to Home</a></p>

<div class="footer">
<div class="contact">
<p>Joel Fernandes · <a href="https://twitter.com/joel_linux">Twitter</a> · <a href="https://www.linkedin.com/in/joelagnel">LinkedIn</a> · <a href="/about-site.html">About site</a></p>
</div>
</div>

</div>

</div>

</body>
</html>
