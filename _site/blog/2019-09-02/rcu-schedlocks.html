<!DOCTYPE html>
<html>
<head>
<title>Making sense of scheduler deadlocks in RCU - Joel Fernandes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="author" content="Joel Fernandes">
<meta name="viewport" content="width=device-width">
<link rel="stylesheet" href="/page.css">
<link rel="stylesheet" href="/css/syntax.css">
<link rel="stylesheet" href="/css/main.css">
</head>
<body>

<div class="page">

<div class="nav">
<p class="navhdr">Joel's site:</p>
<a href="/">Home</a><br>
<a href="/joel/">Resume</a><br>
<a href="/technical.html">Technical Posts</a><br>
<a href="/personal.html">Personal Posts</a><br>
</div>

<div class="recent">
<p class="navhdr">Recent technical posts:</p>
<ul>








<li class="recent">2026-02-08 &raquo;<br><a href="/blog/2026-02-08/rust-clist-kernel.html">CList: Iterating C Linked Lists from Rust in the Kernel</a></li>






<li class="recent">2023-06-25 &raquo;<br><a href="/blog/2023-06-25/svm-vectors.html">SVM and vectors for the curious</a></li>






<li class="recent">2023-06-10 &raquo;<br><a href="/blog/2023-06-10/selinux-procfs.html">SELinux Debugging on ChromeOS</a></li>






<li class="recent">2023-04-28 &raquo;<br><a href="/blog/2023-04-28/hazard-pointers.html">Understanding Hazard Pointers</a></li>






<li class="recent">2023-04-25 &raquo;<br><a href="/blog/2023-04-25/ppc-stack-guards.html">PowerPC stack guard false positives in Linux kernel</a></li>






<li class="recent">2023-02-24 &raquo;<br><a href="/blog/2023-02-24/ycm-working.html">Getting YouCompleteMe working for kernel development</a></li>






<li class="recent">2023-01-29 &raquo;<br><a href="/blog/2023-01-29/figuring-out-herd7.html">Figuring out herd7 memory models</a></li>






<li class="recent">2022-12-15 &raquo;<br><a href="/blog/2022-12-15/modeling-condition-variables.html">Modeling Condition Variables using Formal Methods</a></li>






<li class="recent">2022-11-13 &raquo;<br><a href="/blog/2022-11-13/hrtimer.html">On workings of hrtimer's slack time functionality</a></li>






<li class="recent">2020-10-25 &raquo;<br><a href="/blog/2020-10-25/cpp-ref.html">C++ rvalue references</a></li>












































































</ul>

<hr>

<p class="navhdr">Recent personal posts:</p>
<ul>




<li class="recent">2026-02-10 &raquo;<br><a href="/blog/2026-02-10/new-york-trip.html">New York Trip - Celebrating 40</a></li>






<li class="recent">2026-02-08 &raquo;<br><a href="/blog/2026-02-08/test-post.html">Test Post</a></li>




























































</ul>

<hr>

<p><a href="/technical.html">All technical posts</a><br>
<a href="/personal.html">All personal posts</a></p>
</div>

<div class="site">

<p><a href="/">&laquo; Back to Home</a></p>

<h1 class="title">Making sense of scheduler deadlocks in RCU</h1>
<p class="meta">02 Sep 2019</p>

<div class="post">
<p>Note: At the time of this writing, it is kernel v5.3 release. RCU moves fast
and can change in the future, so some details in this article may be obsolete.</p>

<p>The RCU subsystem and the task scheduler are inter-dependent. They both depend
on each other to function correctly. The scheduler has many data structures
that are protected by RCU. And, RCU may need to wake up threads to perform
things like completing grace periods and callback execution. One such case
where RCU does a wake up and enters the scheduler is
<code class="language-plaintext highlighter-rouge">rcu_read_unlock_special()</code>.</p>

<p>Recently Paul McKenney consolidated RCU flavors. What does this mean?</p>

<p>Consider the following code executing in CPU 0:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>preempt_disable();
rcu_read_lock();
rcu_read_unlock();
preempt_enable();
</code></pre></div></div>
<p>And, consider the following code executing in CPU 1:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = 1;
synchronize_rcu();  // Assume synchronize_rcu
                    // executes after CPU0's rcu_read_lock
b = 2;
</code></pre></div></div>
<p>CPU 0’s execution path shows 2 flavors of RCU readers, one nested into another.
The <code class="language-plaintext highlighter-rouge">preempt_{disable,enable}</code> pair is an <code class="language-plaintext highlighter-rouge">RCU-sched</code> flavor RCU reader
section, while the <code class="language-plaintext highlighter-rouge">rcu_read_{lock,unlock}</code> pair is an <code class="language-plaintext highlighter-rouge">RCU-preempt</code> flavor RCU
reader section.</p>

<p>In older kernels (before v4.20), CPU 1’s <code class="language-plaintext highlighter-rouge">synchronize_rcu()</code>  could return
<em>after</em> CPU 0’s <code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> but before CPU 0’s <code class="language-plaintext highlighter-rouge">preempt_enable()</code>. This
is because <code class="language-plaintext highlighter-rouge">synchronize_rcu()</code> only needs to wait for the “RCU-preempt” flavor
of the RCU grace period to end.</p>

<p>In newer kernels (v4.20 and above), the RCU-preempt and RCU-sched flavors have
been consolidated. This means CPU 1’s <code class="language-plaintext highlighter-rouge">synchronize_rcu()</code> is guaranteed to wait
for both of CPU 1’s <code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> and <code class="language-plaintext highlighter-rouge">preempt_enable()</code> to complete.</p>

<p>Now, lets get a bit more detailed. That <code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> most likely does
very little. However, there are cases where it needs to do more, by calling
<code class="language-plaintext highlighter-rouge">rcu_read_unlock_special()</code>. One such case is if the reader section was
preempted. A few more cases are:</p>

<ul>
  <li>The RCU reader is blocking an expedited grace period, so it needed to report
a quiescent state quickly.</li>
  <li>The RCU reader is blocking a grace period for too long (~100 jiffies on my
system, that’s the default but can be set with
<code class="language-plaintext highlighter-rouge">rcutree.jiffies_till_sched_qs</code> parameter).</li>
</ul>

<p>In all these cases, the <code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> needs to do more work. However,
care must be taken when calling <code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> from the scheduler, that’s
why this article on scheduler deadlocks.</p>

<p>One of the reasons <code class="language-plaintext highlighter-rouge">rcu_read_unlock_special()</code> needs to call into the scheduler
is priority de-boosting:  A task getting preempted in the middle of an RCU
read-side critical section results in blocking the completion of the critical
section and hence could prevent current and future grace periods from ending.
So the priority of the RCU reader may need to be boosted so that it gets enough
CPU time to make progress, and have the grace period end soon. But it also
needs to be de-boosted after the reader section completes. This de-boosting
happens by calling of the <code class="language-plaintext highlighter-rouge">rcu_read_unlock_special()</code> function in the outer
most <code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code>.</p>

<p>What could go wrong with the scheduler using RCU? Let us see this in action.
Consider the following piece of code executed in the scheduler:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  reader()
	{
		rcu_read_lock();
		do_something();     // Preemption happened
                /* Preempted task got boosted */
		task_rq_lock();     // Disables interrupts
                rcu_read_unlock();  // Need to de-boost
		task_rq_unlock();   // Re-enables interrupts
	}
</code></pre></div></div>
<p>Assume that the <code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> needs to de-boost the task’s priority. This
may cause it to enter the scheduler and cause a deadlock due to recursive
locking of RQ/PI locks.</p>

<p>Because of these kind of issues, there has traditionally been a rule that RCU
usage in the scheduler must follow:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>“Thou shall not hold RQ/PI locks across an rcu_read_unlock() if thou not
holding it or disabling IRQ across both both the rcu_read_lock() +
rcu_read_unlock().”
</code></pre></div></div>
<p>More on this rule can be read <a href="https://lwn.net/Articles/453002/">here as well</a>.</p>

<p>Obviously, acquiring RQ/PI locks across the whole <code class="language-plaintext highlighter-rouge">rcu_read_lock()</code> and
<code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> pair would resolve the above situation. Since preemption
and interrupts are disabled across the whole <code class="language-plaintext highlighter-rouge">rcu_read_lock()</code> and
<code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> pair; there is no question of task preemption.</p>

<p>Anyway, the point is <code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> needs to be careful about scheduler
wake-ups; either by avoiding calls to <code class="language-plaintext highlighter-rouge">rcu_read_unlock_special()</code> altogether
(as is the case if interrupts are disabled across the entire RCU reader), or by
detecting situations where a wake up is unsafe. Peter Ziljstra says there’s no
way to know when the scheduler uses RCU, so “generic” detection of the unsafe
condition is a bit tricky.</p>

<p>Now with RCU consolidation, the above situation actually improves. Even if the
scheduler RQ/PI locks are not held across the whole read-side critical sectoin,
but just across that of the <code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code>, then that itself may be enough
to prevent a scheduler deadlock. The reasoning is: during the
<code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code>, we cannot yet report a QS until the RQ/PI lock is itself
released since the act of holding the lock itself means preemption is disabled
and that would cause a QS deferral. As a result, the act of priority
de-boosting would also be deferred and prevent a possible scheduler deadlock.</p>

<p>However, RCU consolidation introduces even newer scenarios where the
<code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code>  has to enter the scheduler, if the “scheduler rules” above
is not honored, as explained below:</p>

<p>Consider the previous code example. Now also assume that the RCU reader is
blocking an expedited RCU grace period. That is just a fancy term for a grace
period that needs to end fast. These grace periods have to complete much more
quickly than normal grace period. An expedited grace period causes currently
running RCU reader sections to receive IPIs that <a href="https://github.com/joelagnel/linux-kernel/blob/rcu/rcu-check-unsafe-scheduler-use-2/kernel/rcu/tree_exp.h#L641">set a
hint</a>.
Setting of this hint results in the outermost <code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> calling
<code class="language-plaintext highlighter-rouge">rcu_read_unlock_special()</code>, which otherwise would not occur.
When <code class="language-plaintext highlighter-rouge">rcu_read_unlock_special()</code> gets called in this scenario, it tries to get
more aggressive once it <a href="https://github.com/joelagnel/linux-kernel/blob/rcu/rcu-check-unsafe-scheduler-use-2/kernel/rcu/tree_plugin.h#L627">notices
that</a>
the reader has blocked an expedited RCU grace period. In particular, it
<a href="https://github.com/joelagnel/linux-kernel/blob/rcu/rcu-check-unsafe-scheduler-use-2/kernel/rcu/tree_plugin.h#L620">notices that preemption is
disabled</a>
and so the grace period cannot end due to RCU consolidation. Out of
desperation, it raises a softirq (<code class="language-plaintext highlighter-rouge">raise_softirq()</code>) in the hope that the next
time the softirq runs, the grace period could be ended quickly before the
scheduler tick occurs. But that can cause a scheduler deadlock by way of entry
into the scheduler due to a ksoftirqd-wakeup.</p>

<p>The cure for this problem is the same, holding the RQ/PI locks across the
entire reader section results in no question of a scheduler related deadlock
due to recursively acquiring of these locks; because there would be no question
of expedited-grace-period IPIs, hence no question of setting of any hints, and
hence no question of calling <code class="language-plaintext highlighter-rouge">rcu_read_unlock_special()</code> from scheduler code.
For a twist of the IPI problem, see <a href="#special-note">special note</a>.</p>

<p>However, the RCU consolidation throws yet another curve ball. Paul McKenney
<a href="https://lore.kernel.org/lkml/20190627173831.GW26519@linux.ibm.com/">explained on
LKML</a> that
there is yet another situation now due to RCU consolidation that can cause
scheduler deadlocks.</p>

<p>Consider the following code, where <code class="language-plaintext highlighter-rouge">previous_reader()</code> and <code class="language-plaintext highlighter-rouge">current_reader()</code>
execute in quick succession in the context of the same task:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       previous_reader()
	{
		rcu_read_lock();
		do_something();      // Preemption or IPI happened
		local_irq_disable(); // Cannot be the scheduler
		do_something_else();
		rcu_read_unlock();  // As IRQs are off, defer QS report
                                    //but set deferred_qs bit in 
                                    //rcu_read_unlock_special
		do_some_other_thing();
		local_irq_enable();
	}

        // QS from previous_reader() is still deferred.
	current_reader() 
	{
		local_irq_disable();  // Might be the scheduler.
		do_whatever();
		rcu_read_lock();
		do_whatever_else();
		rcu_read_unlock();    // Must still defer reporting QS
		do_whatever_comes_to_mind();
		local_irq_enable();
	}
</code></pre></div></div>
<p>Here <code class="language-plaintext highlighter-rouge">previous_reader()</code> had a preemption; even though the <code class="language-plaintext highlighter-rouge">current_reader()</code>
did not - but the <code class="language-plaintext highlighter-rouge">current_reader()</code> still needs to call
<code class="language-plaintext highlighter-rouge">rcu_read_unlock_special()</code> from the scheduler!  This situation would not
happen in the pre-consolidated-RCU world because <code class="language-plaintext highlighter-rouge">previous_reader()</code>’s
<code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> would have taken care of it.</p>

<p>As you can see, just following the scheduler rule of disabling interrupts
across the entire reader section does not help. To detect the above scenario; a
new bitfield  <code class="language-plaintext highlighter-rouge">deferred_qs</code> has been
<a href="https://lore.kernel.org/patchwork/patch/1057344/">added</a> to the
<code class="language-plaintext highlighter-rouge">task_struct::rcu_read_unlock_special</code> union. Now what happens is, at
<code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code>-time, the <code class="language-plaintext highlighter-rouge">previous reader()</code> sets this bit, and the
<code class="language-plaintext highlighter-rouge">current_reader()</code> checks this bit. If set, the call to <code class="language-plaintext highlighter-rouge">raise_softirq()</code> is
avoided thus eliminating the possibility of a scheduler deadlock.</p>

<p>Hopefully no other scheduler deadlock issue is lurking!</p>

<p>Coming back to the scheduler rule, I have been running overnight rcutorture
tests to detect if this rule is ever violated. Here is the <a href="https://github.com/joelagnel/linux-kernel/commits/rcu/rcu-check-unsafe-scheduler-use-2">test
patch</a>
checking for the unsafe condition. So far I have not seen this condition occur
which is a good sign.</p>

<p>I may need to check with Paul McKenney about whether proposing this checking
for mainline is worth it. Thankfully, LPC 2019 is right around the corner! ;-)
——–</p>
<h4 id="special-note">Special Note</h4>
<p>[1] The expedited IPI interrupting an RCU reader has a variation. For an
example see below where the IPI was not received, but we still have a problem
because the <code class="language-plaintext highlighter-rouge">-&gt;need_qs</code> bit in the <code class="language-plaintext highlighter-rouge">rcu_read_unlock_special union</code> got set even
though the expedited grace period started after IRQs were disabled. The start
of the expedited grace period would set the <code class="language-plaintext highlighter-rouge">rnp-&gt;expmask</code> bit for the CPU. In
the unlock path, because the <code class="language-plaintext highlighter-rouge">-&gt;need_qs</code> bit is set, it will call
<code class="language-plaintext highlighter-rouge">rcu_read_unlock_special()</code> and risk a deadlock by way of a <code class="language-plaintext highlighter-rouge">ksoftirqd</code> wakeup
because <code class="language-plaintext highlighter-rouge">exp</code> in that function is true.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CPU 0                         CPU 1
preempt_disable();
rcu_read_lock();

// do something real long

// Scheduler-tick sets
// -&gt;need_qs as reader is
// held for too long.

local_irq_disable();
                              // Expedited GP started
// Exp IPI not received
// because IRQs are off.

local_irq_enable();

// Here rcu_read_unlock will
// still call ..._special()
// as -&gt;need_qs got set.
rcu_read_unlock();

preempt_enable();
</code></pre></div></div>
<p>The fix for this issue is the same as described earlier, disabling interrupts
across both <code class="language-plaintext highlighter-rouge">rcu_read_lock()</code> and <code class="language-plaintext highlighter-rouge">rcu_read_unlock()</code> in the scheduler path.</p>

</div>

<p><a href="/">&laquo; Back to Home</a></p>

<hr>
<h2>Comments</h2>
<script src="https://utteranc.es/client.js"
        repo="joelagnel/joelfernandes.org"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


<div class="footer">
<div class="contact">
<p>© Joel Fernandes · <a href="https://twitter.com/joel_linux">Twitter</a> · <a href="https://www.linkedin.com/in/joelagnel">LinkedIn</a> · <a href="/about-site.html">About site</a></p>
</div>
</div>

</div>

</div>

</body>
</html>
