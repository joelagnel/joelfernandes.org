<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rcu on JoelFernandes.org</title>
    <link>http://localhost:1313/categories/rcu/</link>
    <description>Recent content in Rcu on JoelFernandes.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/categories/rcu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Making sense of scheduler deadlocks in RCU</title>
      <link>http://localhost:1313/blog/1/01/01/making-sense-of-scheduler-deadlocks-in-rcu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/1/01/01/making-sense-of-scheduler-deadlocks-in-rcu/</guid>
      <description>Note: At the time of this writing, it is kernel v5.3 release. RCU moves fast and can change in the future, so some details in this article may be obsolete.&#xA;The RCU subsystem and the task scheduler are inter-dependent. They both depend on each other to function correctly. The scheduler has many data structures that are protected by RCU. And, RCU may need to wake up threads to perform things like completing grace periods and callback execution.</description>
    </item>
    <item>
      <title>SRCU state double scan</title>
      <link>http://localhost:1313/blog/1/01/01/srcu-state-double-scan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/1/01/01/srcu-state-double-scan/</guid>
      <description>The SRCU flavor of RCU uses per-cpu counters to detect that every CPU has passed through a quiescent state for a particular SRCU lock instance (srcu_struct).&#xA;There&amp;rsquo;s are total of 4 counters per-cpu. One pair for locks, and another for unlocks. You can think of the SRCU instance to be split into 2 parts. The readers sample srcu_idx and decided which part to use. Each part corresponds to one pair of lock and unlock counters.</description>
    </item>
    <item>
      <title>Understanding Hazard Pointers</title>
      <link>http://localhost:1313/blog/1/01/01/understanding-hazard-pointers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/1/01/01/understanding-hazard-pointers/</guid>
      <description>Introduction In concurrent systems, managing shared resources efficiently and safely is of paramount importance. Hazard pointers are a powerful synchronization mechanism that can be used to address this issue. In this post, we will explore how hazard pointers work, provide a simple example to illustrate their usage, and compare them with RCU (Read-Copy-Update). Additionally, we will dive into the implementation details of hazard pointers, including the per-CPU and per-thread data structures used to maintain them.</description>
    </item>
  </channel>
</rss>
