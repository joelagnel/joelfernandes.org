<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on JoelFernandes.org</title>
    <link>http://localhost:1313/categories/linux/</link>
    <description>Recent content in Linux on JoelFernandes.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Feb 2018 23:22:39 -0800</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>USDT for reliable Userspace event tracing</title>
      <link>http://localhost:1313/blog/2018/02/10/usdt-for-reliable-userspace-event-tracing/</link>
      <pubDate>Sat, 10 Feb 2018 23:22:39 -0800</pubDate>
      <guid>http://localhost:1313/blog/2018/02/10/usdt-for-reliable-userspace-event-tracing/</guid>
      <description>Userspace program when compiled to native can place tracepoints in them using a USDT (User Statically Defined Tracing), the details of the tracepoints (such as address and arguments) are placed as a note in the ELF binary for other tools to interpret. This at first seems much better than using Uprobes directly on userspace functions, since the latter not only needs symbol information from the binary but is also at the mercy of compiler optimizations and function inlining.</description>
    </item>
    <item>
      <title>ARMv8: flamegraph and NMI support</title>
      <link>http://localhost:1313/blog/2016/12/31/armv8-flamegraph-and-nmi-support/</link>
      <pubDate>Sat, 31 Dec 2016 22:29:26 -0700</pubDate>
      <guid>http://localhost:1313/blog/2016/12/31/armv8-flamegraph-and-nmi-support/</guid>
      <description>Non-maskable interrupts (NMI) is a really useful feature for debugging, that hardware can provide. Unfortunately ARM doesn&amp;rsquo;t provide an out-of-the-box NMI interrupt mechanism. This post shows a flamegraph issue due to missing NMI support, and the upstream work being done to simulate NMI in ARMv8.&#xA;Some great Linux kernel features that rely on NMI to work properly are:&#xA;Backtrace from all CPUs: A number of places in the kernel rely on dumping the stacks of all CPUs at the time of a failure to determine what was going on.</description>
    </item>
    <item>
      <title>Ftrace events mechanism</title>
      <link>http://localhost:1313/blog/2016/06/18/ftrace-events-mechanism/</link>
      <pubDate>Sat, 18 Jun 2016 22:29:26 -0700</pubDate>
      <guid>http://localhost:1313/blog/2016/06/18/ftrace-events-mechanism/</guid>
      <description>Ftrace events are a mechanism that allows different pieces of code in the kernel to &amp;lsquo;broadcast&amp;rsquo; events of interest. Such as a scheduler context-switch sched_switch for example. In the scheduler core&amp;rsquo;s __schedule function, you&amp;rsquo;ll see something like: trace_sched_switch(preempt, prev, next); This immediately results in a write to a per-cpu ring buffer storing info about what the previous task was, what the next one is, and whether the switch is happening as a result of kernel preemption (versus happening for other reasons such as a task waiting for I/O completion).</description>
    </item>
    <item>
      <title>TIF_NEED_RESCHED: why is it needed</title>
      <link>http://localhost:1313/blog/2016/03/20/tif_need_resched-why-is-it-needed/</link>
      <pubDate>Sun, 20 Mar 2016 01:44:32 -0700</pubDate>
      <guid>http://localhost:1313/blog/2016/03/20/tif_need_resched-why-is-it-needed/</guid>
      <description>TIF_NEED_RESCHED is one of the many &amp;ldquo;thread information flags&amp;rdquo; stored along side every task in the Linux Kernel. One of the flags which is vital to the working of preemption is TIF_NEED_RESCHED. Inorder to explain why its important and how it works, I will go over 2 cases where TIF_NEED_RESCHED is used.&#xA;Preemption Preemption is the process of forceably grabbing CPU from a user or kernel context and giving it to someone else (user or kernel).</description>
    </item>
    <item>
      <title>Tying 2 voltage sources/signals together</title>
      <link>http://localhost:1313/blog/2015/12/25/tying-2-voltage-sources/signals-together/</link>
      <pubDate>Fri, 25 Dec 2015 14:51:29 -0600</pubDate>
      <guid>http://localhost:1313/blog/2015/12/25/tying-2-voltage-sources/signals-together/</guid>
      <description>Recently I asked a question on StackExchange about what happens when 2 voltage signals are tied together. What&amp;rsquo;s the resultant voltage and what decides this voltage? The whole train of thought started when I was trying to contemplate what happens when you use pull-ups on signals that are not Open Drain.&#xA;I create and simulated a Circuit with the same scenario in LTSpice. &amp;ldquo;V&amp;rdquo; is the voltage between the &amp;ldquo;+&amp;rdquo; terminals of V1 and V2 and its shown on the right of the simulation.</description>
    </item>
    <item>
      <title>MicroSD card remote switch</title>
      <link>http://localhost:1313/blog/2014/06/04/microsd-card-remote-switch/</link>
      <pubDate>Wed, 04 Jun 2014 06:12:55 -0500</pubDate>
      <guid>http://localhost:1313/blog/2014/06/04/microsd-card-remote-switch/</guid>
      <description>Recently, I&amp;rsquo;ve been wanting to remotely be able to program a MicroSD card with a new bootloader or filesystem without removing the card from its embedded target board (such as a Beaglebone or Pandaboard). Due to the lack of any such existing tools, I decided to design my own board. Finally have got it working, below are some pictures and a screencast demo video of the switcher in action! I sprinkled some power and status LED to show the user what&amp;rsquo;s going on.</description>
    </item>
    <item>
      <title>Linux Spinlock Internals</title>
      <link>http://localhost:1313/blog/2014/05/07/linux-spinlock-internals/</link>
      <pubDate>Wed, 07 May 2014 22:42:45 -0500</pubDate>
      <guid>http://localhost:1313/blog/2014/05/07/linux-spinlock-internals/</guid>
      <description>This article tries to clarify how spinlocks are implemented in the Linux kernel and how they should be used correctly in the face of preemption and interrupts. The focus of this article will be more on basic concepts than details, as details tend to be forgotten more easily and shouldn&amp;rsquo;t be too hard to look up although attention is paid to it to the extent that it helps understanding.&#xA;Fundamentally somewhere in include/linux/spinlock.</description>
    </item>
    <item>
      <title>Design of fork followed by exec in Linux</title>
      <link>http://localhost:1313/blog/2014/04/22/design-of-fork-followed-by-exec-in-linux/</link>
      <pubDate>Tue, 22 Apr 2014 23:06:11 -0500</pubDate>
      <guid>http://localhost:1313/blog/2014/04/22/design-of-fork-followed-by-exec-in-linux/</guid>
      <description>A lot of folks ask why do you have to do fork and then an exec, to execute a new program? and why can&amp;rsquo;t it be done in one step?, or why does fork create a copy-on-writed address space, to only have it thrown away later when you do an exec?. So I decided do a small write up about this topic.&#xA;On a separate note, firstly it is important to remember that fork is not used for threading, its primary use is to create a separate process, that is a child of the parent process that called fork.</description>
    </item>
    <item>
      <title>On workings of hrtimer&#39;s slack time functionality</title>
      <link>http://localhost:1313/blog/1/01/01/on-workings-of-hrtimers-slack-time-functionality/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/1/01/01/on-workings-of-hrtimers-slack-time-functionality/</guid>
      <description>Below are some notes I wrote while studying hrtimer slack behavior (range timers), which was added to reduce wakeups and save power, in the commit below. The idea is that:&#xA;Normal hrtimers will have both a soft and hard expiry which are equal to each other. But hrtimers with timer slack will have a soft expiry and a hard expiry which is the soft expiry + delta. The slack/delay effect is achieved by splitting the execution of the timer function, and the programming of the next timer event into 2 separate steps.</description>
    </item>
  </channel>
</rss>
