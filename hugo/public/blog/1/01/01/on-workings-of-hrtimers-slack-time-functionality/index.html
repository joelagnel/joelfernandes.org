<!DOCTYPE html>


<html class="no-js" lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  <title>On Workings of Hrtimer&#39;s Slack Time Functionality - JoelFernandes.org</title>
  <meta name="author" content="Joel Fernandes">

  
  <meta name="description" content="Below are some notes I wrote while studying hrtimer slack behavior (range timers), which was added to reduce wakeups and save power, in the commit …">

  
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="canonical" href="http://localhost:1313/blog/1/01/01/on-workings-of-hrtimers-slack-time-functionality/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="\/javascripts\/libs\/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
  
</head>
<body   >
  <header role="banner"><div>
<div style="margin-right:50px;float:left;">
  <h1><a href="/">JoelFernandes.org</a></h1>
  
</div>
<div style="float:left;" class="hnav">
 <br>
 
 <a href="/categories/">Blog posts by category.</a><br>
 <a href="/blog/archives/">Archive of all blog posts.</a><br>
 <a href="/resources/">Presentations and other work.</a><br>
</div>
<div style="float:right;">
<img src="/images/peng.png" height=100 width=100>
</div>
</div></header>

  <div id="main">
    <div id="content">
      
<div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">On workings of hrtimer&#39;s slack time functionality</h1>
    
    
      <p class="meta">
        
        
           | <a href="http://localhost:1313/blog/1/01/01/on-workings-of-hrtimers-slack-time-functionality/#disqus_thread"
             data-disqus-identifier="http://localhost:1313/blog/1/01/01/on-workings-of-hrtimers-slack-time-functionality/">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>Below are some notes I wrote while studying hrtimer slack behavior (range
timers), which was added to reduce wakeups and save power, in the commit below.
The idea is that:</p>
<ol>
<li>Normal hrtimers will have both a soft and hard expiry which are equal to each other.</li>
<li>But hrtimers with timer slack will have a soft expiry and a hard expiry which is the soft expiry + delta.</li>
</ol>
<p>The slack/delay effect is achieved by splitting the execution of the timer
function, and the programming of the next timer event into 2 separate steps.
That is, we execute the timer function as soon as we notice that its soft
expiry has passed (<code>hrtimer_run_queues()</code>). However, for programming the next
timer interrupt, we only look at the hard expiry (<code>hrtimer_update_next_event()</code>
-&gt; <code>__hrtimer_get_next_event()</code> -&gt;
<code>__hrtimer_next_event_base()</code>-&gt;<code>hrtimer_get_expires()</code>). As a result, the only
way a slack-based timer will execute before its slack time elapses, is, if
another timer without any slack time gets queued such that it hard-expires
before the slack time of the slack-based timer passes.</p>
<p>The commit containing the original code added for range timers is:</p>
<pre tabindex="0"><code>commit 654c8e0b1c623b156c5b92f28d914ab38c9c2c90
Author: Arjan van de Ven &lt;arjan@linux.intel.com&gt;
Date:   Mon Sep 1 15:47:08 2008 -0700

    hrtimer: turn hrtimers into range timers
   
    this patch turns hrtimers into range timers;
    they have 2 expire points
    1) the soft expire point
    2) the hard expire point
   
    the kernel will do it&#39;s regular best effort attempt to get the timer run at
the hard expire point. However, if some other time fires after the soft expire
point, the kernel now has the freedom to fire this timer at this point, and
thus grouping the events and preventing a power-expensive wakeup in the future.
</code></pre><p>The original code seems a bit buggy. I got a bit confused about how/where we
handle the case in <code>hrtimer_interrupt()</code> where other normal timers that expire
before the slack time elapses, have their next timer interrupt programmed
correctly such that the interrupt goes off before the slack time passes.</p>
<p>To see the issue, consider the case where we have 2 timers queued:</p>
<ol>
<li>
<p>The first one soft expires at t = 10, and say it has a slack of 50, so it hard expires at t = 60.</p>
</li>
<li>
<p>The second one is a normal timer, so the soft/hard expiry of it is both at t = 30.</p>
</li>
</ol>
<p>Now say, an hrtimer interrupt happens at t=5 courtesy of an unrelated expiring
timer. In the below code, we notice that the next expiring timer is (the one
with slack one), which has not soft-expired yet. So we have no reason to run
it. However, we reprogram the next timer interrupt to be t=60 which is its hard
expiry time (this is stored in expires_next to use as the value to program the
next timer interrupt with).  Now we have a big problem, because the timer
expiring at t=30 will not run in time and run much later.</p>
<p>As shown below, the loop in <code>hrtimer_interrupt()</code> goes through all the active
timers in the timerqueue, <code>_softexpires</code> is made to be the real expiry, and the
old <code>_expires</code> now becomes <code>_softexpires + slack</code>.</p>
<pre tabindex="0"><code>       while((node = timerqueue_getnext(&amp;base-&gt;active))) {
              struct hrtimer *timer;

              timer = container_of(node, struct hrtimer, node);

              /*
               * The immediate goal for using the softexpires is
               * minimizing wakeups, not running timers at the
               * earliest interrupt after their soft expiration.
               * This allows us to avoid using a Priority Search
               * Tree, which can answer a stabbing querry for
               * overlapping intervals and instead use the simple
               * BST we already have.
               * We don&#39;t add extra wakeups by delaying timers that
               * are right-of a not yet expired timer, because that
               * timer will have to trigger a wakeup anyway.
               */

              if (basenow.tv64 &lt; hrtimer_get_softexpires_tv64(timer)) {
                      ktime_t expires;

                      expires = ktime_sub(hrtimer_get_expires(timer),
                                          base-&gt;offset);
                      if (expires.tv64 &lt; expires_next.tv64)
                              expires_next = expires;
                      break;
              }

              __run_hrtimer(timer, &amp;basenow);
      }
</code></pre><p>However, this seems to be an old kernel issue, as, in upstream v6.0, I believe
the next hrtimer interrupt will be programmed correctly because
<code>__hrtimer_next_event_base()</code> calls <code>hrtimer_get_expires()</code> which correctly use
the &ldquo;hard expiry&rdquo; times to do the programming.</p>
</div>

  <footer>
    <p class="meta">
      
<span class="byline author vcard">Posted by <span class="fn">Joel Fernandes</span></span>
      
      <div class="post-categories">
  
    
      
      <a href="/categories/#timers">timers</a>
      &nbsp;
      
      <a href="/categories/#linux">linux</a>
      &nbsp;
      
      <a href="/categories/#kernel">kernel</a>
      &nbsp;
      
    
  
</div>
    </p>
    
      <div class="sharing">
  
  
  
</div>
    
    <p class="meta">
      
        <a class="basic-alignment left" href="http://localhost:1313/blog/1/01/01/powerpc-stack-guard-false-positives-in-linux-kernel/" title="Previous Post: PowerPC stack guard false positives in Linux kernel">&laquo; PowerPC stack guard false positives in Linux kernel</a>
      
      
        <a class="basic-alignment right" href="http://localhost:1313/blog/1/01/01/modeling-lack-of-store-ordering-using-pluscal-and-a-wishlist/" title="Next Post: Modeling (lack of) store ordering using PlusCal - and a wishlist">Modeling (lack of) store ordering using PlusCal - and a wishlist &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
  </section>

</div>

<aside class="sidebar">
  <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="http://localhost:1313/blog/2023/06/25/svm-and-vectors-for-the-curious/">SVM and vectors for the curious</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2018/12/22/dumping-user-and-kernel-stacks-on-kernel-events/">Dumping User and Kernel stacks on Kernel events</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2018/02/10/usdt-for-reliable-userspace-event-tracing/">USDT for reliable Userspace event tracing</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2016/12/31/armv8-flamegraph-and-nmi-support/">ARMv8: flamegraph and NMI support</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2016/06/18/ftrace-events-mechanism/">Ftrace events mechanism</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2016/03/20/tif_need_resched-why-is-it-needed/">TIF_NEED_RESCHED: why is it needed</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2015/12/25/tying-2-voltage-sources/signals-together/">Tying 2 voltage sources/signals together</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2014/06/04/microsd-card-remote-switch/">MicroSD card remote switch</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2014/05/07/linux-spinlock-internals/">Linux Spinlock Internals</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2014/04/24/studying-cache-line-sharing-effects-on-smp-systems/">Studying cache-line sharing effects on SMP systems</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2014/04/22/design-of-fork-followed-by-exec-in-linux/">Design of fork followed by exec in Linux</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/"></a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/bpfd-running-bcc-tools-remotely-across-systems/">BPFd- Running BCC tools remotely across systems</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/c-rvalue-references/">C&#43;&#43; rvalue references</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/categories/">Categories</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/joel/">false</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/figuring-out-herd7-memory-models/">Figuring out herd7 memory models</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/getting-youcompleteme-working-for-kernel-development/">Getting YouCompleteMe working for kernel development</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/gus-global-unbounded-sequences/">GUS (Global Unbounded Sequences)</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/archives/">List of articles</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/making-sense-of-scheduler-deadlocks-in-rcu/">Making sense of scheduler deadlocks in RCU</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/modeling-lack-of-store-ordering-using-pluscal-and-a-wishlist/">Modeling (lack of) store ordering using PlusCal - and a wishlist</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/on-workings-of-hrtimers-slack-time-functionality/">On workings of hrtimer&#39;s slack time functionality</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/powerpc-stack-guard-false-positives-in-linux-kernel/">PowerPC stack guard false positives in Linux kernel</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/rcu-and-dynticks-idle-mode/">RCU and dynticks-idle mode</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/rcu-preempt-what-happens-on-a-context-switch/">RCU-preempt: What happens on a context switch</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/resources/">Resources</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/selinux-debugging-on-chromeos/">SELinux Debugging on ChromeOS</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/single-stepping-the-kernels-c-code/">Single-stepping the kernel&#39;s C code</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/srcu-state-double-scan/">SRCU state double scan</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/understanding-hazard-pointers/">Understanding Hazard Pointers</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>About Me</h1>
  <p>A little something about me.</p>
</section>
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2025 - Joel Fernandes -
  <span class="credit">Powered by <a href="https://gohugo.io">Hugo</a></span>
</p></footer>
  
</body>
</html>