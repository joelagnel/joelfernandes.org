<!DOCTYPE html>


<html class="no-js" lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  <title>TIF_NEED_RESCHED: Why Is It Needed - JoelFernandes.org</title>
  <meta name="author" content="Joel Fernandes">

  
  <meta name="description" content="TIF_NEED_RESCHED is one of the many &amp;ldquo;thread information flags&amp;rdquo; stored along side every task in the Linux Kernel. One of the flags which is â€¦">

  
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="canonical" href="http://localhost:1313/blog/2016/03/20/tif_need_resched-why-is-it-needed/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="\/javascripts\/libs\/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
  
</head>
<body   >
  <header role="banner"><div>
<div style="margin-right:50px;float:left;">
  <h1><a href="/">JoelFernandes.org</a></h1>
  
</div>
<div style="float:left;" class="hnav">
 <br>
 
 <a href="/categories/">Blog posts by category.</a><br>
 <a href="/blog/archives/">Archive of all blog posts.</a><br>
 <a href="/resources/">Presentations and other work.</a><br>
</div>
<div style="float:right;">
<img src="/images/peng.png" height=100 width=100>
</div>
</div></header>

  <div id="main">
    <div id="content">
      
<div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">TIF_NEED_RESCHED: why is it needed</h1>
    
    
      <p class="meta">
        
<time datetime="2016-03-20T01:44:32-07:00" pubdate data-updated="true">Mar 20, 2016</time>

        
           | <a href="http://localhost:1313/blog/2016/03/20/tif_need_resched-why-is-it-needed/#disqus_thread"
             data-disqus-identifier="http://localhost:1313/blog/2016/03/20/tif_need_resched-why-is-it-needed/">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p><code>TIF_NEED_RESCHED</code> is one of the many &ldquo;thread information flags&rdquo; stored along side every task in the Linux Kernel. One of the flags which is vital to the working of preemption is <code>TIF_NEED_RESCHED</code>. Inorder to explain why its important and how it works, I will go over 2 cases where <code>TIF_NEED_RESCHED</code> is used.</p>
<h2 id="preemption">Preemption</h2>
<p>Preemption is the process of forceably grabbing CPU from a user or kernel context and giving it to someone else (user or kernel). It is the means for timesharing a CPU between competing tasks (I will use task as terminology for process).
In Linux, the way it works is a timer interrupt (called the tick) interrupts the task that is running and makes a decision about whether a task or a kernel code path (executing on behalf of a task like in a syscall) is to be preempted. This decision is based on whether the task has been running long-enough and something higher priority woke up and needs CPU now, or is ready to run.</p>
<p>These things happen in <code>scheduler_tick()</code>, the exact path is <em>TIMER HARDWARE INTERRUPT</em> -&gt; <code>scheduler_tick</code> -&gt; <code>task_tick_fair</code> -&gt; <code>entity_tick</code> -&gt; <code>check_preempt_tick</code>.
<code>entity_tick()</code> updates various run time statistics of the task, and <code>check_preempt_tick()</code> is where TIF_NEED_RESCHED is set.</p>
<p>Here&rsquo;s a small bit of code in <code>check_preempt_tick</code></p>
<pre tabindex="0"><code>check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)
{
        unsigned long ideal_runtime, delta_exec;
        struct sched_entity *se;
        s64 delta;

        ideal_runtime = sched_slice(cfs_rq, curr);
        delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;
        if (delta_exec &gt; ideal_runtime) {
                resched_curr(rq_of(cfs_rq));
                /*
                 * The current task ran long enough, ensure it doesn&#39;t get
                 * re-elected due to buddy favours.
                 */
                clear_buddies(cfs_rq, curr);
                return;
        }
</code></pre><p>Here you see a decision is made that the process ran long enough based on its runtime and if so call <code>resched_curr</code>. Turns out <code>resched_curr</code> sets the <code>TIF_NEED_RESCHED</code> for the current task! This informs whoever looks at the flag, that this process should be scheduled out soon.</p>
<p>Even though this flag is set at this point, the task is not going to be preempted yet. This is because preemption happens at specific points such as exit of interrupts. If the flag is set because the timer interrupt (scheduler decided) decided that something of higher priority needs CPU now and sets <code>TIF_NEED_RESCHED</code>, then at the exit of the timer interrupt (interrupt exit path), <code>TIF_NEED_RESCHED</code> is checked, and because it is set - <code>schedule()</code> is called causing context switch to happen to another process of higher priority, instead of just returning to the existing process that the timer interrupted normally would.
Lets examine where this happens.</p>
<p>For return from interrupt to user-mode:</p>
<p>If the tick interrupt happened user-mode code was running, then in somewhere in the interrupt exit path for x86, this call chain calls schedule <code>ret_from_intr</code> -&gt; <code>reint_user</code> -&gt; <code>prepare_exit_to_usermode</code>. Here the need_reched flag is checked, and if true <code>schedule()</code> is called.</p>
<p>For return from interrupt to kernel mode, things are a bit different (skip this para if you think it&rsquo;ll confuse you).</p>
<p>This feature requires kernel preemption to be enabled. The call chain doing the preemption is: <code>ret_from_intr</code> -&gt; <code>reint_kernel</code> -&gt; <code>preempt_schedule_irq</code> (see <code>arch/x86/entry/entry_64.S</code>) which calls <code>schedule</code>.
Note that, for return to kernel mode, I see that <code>preempt_schedule_irq</code> calls <code>schedule</code> anyway whether need_resched flag is set or not, this is probably Ok but I am wondering if need_resched should be checked here before <code>schedule</code> is called. Perhaps it would be an optimiziation to avoid unecessarily calling <code>schedule</code>. One reason for not doing so would be, say any other interrupt other than timer tick is returning to the interrupted kernel space, then in these cases for example - if the timer tick didn&rsquo;t get a chance to run (because all other local interrupts are disabled in Linux until an interrupt finishes, in this case our non-timer interrupt), then we&rsquo;d want the exit path of the non-timer interrupt to behave just like the exit path of the timer tick interrupt would behave, whether need_resched is set or not.</p>
<h2 id="critical-sections-in-kernel-code-where-preemption-is-off">Critical sections in kernel code where preemption is off</h2>
<p>One nice example of a code path where preemption is off is the <code>mutex_lock</code> path in the kernel. In the kernel, there is an optimization where if a mutex is already locked and not available, but if the lock owner (the task currently holding the lock) is running on another CPU, then the mutex temporarily becomes a spinlock (which means it will spin until it can get the lock) instead of behaving like a mutex (which sleeps until the lock is available). The pseudo code looks like this:</p>
<pre tabindex="0"><code>mutex_lock() {
  disable_preempt();
  if (lock can&#39;t be acquired and the lock holding task is currently running) {
	while (lock_owner_running &amp;&amp; !need_resched()) {
		cpu_relax();
	}
  }
  enable_preempt();
  acquire_lock_or_sleep();
}
</code></pre><p>The lock path does exactly what I described. <code>cpu_relax()</code> is arch specific which is called when the CPU has to do nothing but wait. It gives hints to the CPU that it can put itself into an idle state or use its resources for someone else. For x86, it involves calling the <a href="https://en.wikipedia.org/wiki/HLT">halt instruction</a>.</p>
<p>What I noticed is the Ftrace latency tracer complained about a long delay in the preempt disabled path of mutex_lock for one of my tests, and I made some <a href="http://www.spinics.net/lists/linux-rt-users/msg15022.html">noise</a> about it on the mailing list. Disabling preemption for long periods is generally a bad thing to do because during this duration, no other task can be scheduled on the CPU. However, Steven <a href="http://www.spinics.net/lists/linux-rt-users/msg15025.html">pointed out that</a> for this particular case, since we&rsquo;re checking for need_resched() and breaking out of the loop, we should be Ok. What would happen is, the scheduling timer interrupt (which calls <code>scheduler_tick()</code> I mentioned earlier) comes in and checks if higher priority tasks need CPU, and if they do, it sets <code>TIF_NEED_RESCHED</code>. Once the timer interrupt returns to our tightly spinning loop in mutex_lock, we would break out of the loop having noticed <code>need_resched()</code> and, re-enable preemption as shown in the code above. Thus the long duration of preemption doesn&rsquo;t turn out to be a problem as long tasks that need CPU are prioritized correctly. <code>need_resched()</code> achieved this fairness.</p>
<p>Next time you see <code>if (need_resched())</code> in kernel code, you&rsquo;ll have a better idea why its there :). Let me know your comments if any.</p>
</div>

  <footer>
    <p class="meta">
      
<span class="byline author vcard">Posted by <span class="fn">Joel Fernandes</span></span>
      
<time datetime="2016-03-20T01:44:32-07:00" pubdate data-updated="true">Mar 20, 2016</time>

      <div class="post-categories">
  
    
      
      <a href="/categories/#linux">linux</a>
      &nbsp;
      
      <a href="/categories/#kernel">kernel</a>
      &nbsp;
      
      <a href="/categories/#scheduler">scheduler</a>
      &nbsp;
      
    
  
</div>
    </p>
    
      <div class="sharing">
  
  
  
</div>
    
    <p class="meta">
      
        <a class="basic-alignment left" href="http://localhost:1313/blog/2015/12/25/tying-2-voltage-sources/signals-together/" title="Previous Post: Tying 2 voltage sources/signals together">&laquo; Tying 2 voltage sources/signals together</a>
      
      
        <a class="basic-alignment right" href="http://localhost:1313/blog/2016/06/18/ftrace-events-mechanism/" title="Next Post: Ftrace events mechanism">Ftrace events mechanism &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
  </section>

</div>

<aside class="sidebar">
  <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="http://localhost:1313/blog/2023/06/25/svm-and-vectors-for-the-curious/">SVM and vectors for the curious</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2018/12/22/dumping-user-and-kernel-stacks-on-kernel-events/">Dumping User and Kernel stacks on Kernel events</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2018/02/10/usdt-for-reliable-userspace-event-tracing/">USDT for reliable Userspace event tracing</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2016/12/31/armv8-flamegraph-and-nmi-support/">ARMv8: flamegraph and NMI support</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2016/06/18/ftrace-events-mechanism/">Ftrace events mechanism</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2016/03/20/tif_need_resched-why-is-it-needed/">TIF_NEED_RESCHED: why is it needed</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2015/12/25/tying-2-voltage-sources/signals-together/">Tying 2 voltage sources/signals together</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2014/06/04/microsd-card-remote-switch/">MicroSD card remote switch</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2014/05/07/linux-spinlock-internals/">Linux Spinlock Internals</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2014/04/24/studying-cache-line-sharing-effects-on-smp-systems/">Studying cache-line sharing effects on SMP systems</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/2014/04/22/design-of-fork-followed-by-exec-in-linux/">Design of fork followed by exec in Linux</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/"></a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/bpfd-running-bcc-tools-remotely-across-systems/">BPFd- Running BCC tools remotely across systems</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/c-rvalue-references/">C&#43;&#43; rvalue references</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/categories/">Categories</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/joel/">false</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/figuring-out-herd7-memory-models/">Figuring out herd7 memory models</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/getting-youcompleteme-working-for-kernel-development/">Getting YouCompleteMe working for kernel development</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/gus-global-unbounded-sequences/">GUS (Global Unbounded Sequences)</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/archives/">List of articles</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/making-sense-of-scheduler-deadlocks-in-rcu/">Making sense of scheduler deadlocks in RCU</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/modeling-lack-of-store-ordering-using-pluscal-and-a-wishlist/">Modeling (lack of) store ordering using PlusCal - and a wishlist</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/on-workings-of-hrtimers-slack-time-functionality/">On workings of hrtimer&#39;s slack time functionality</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/powerpc-stack-guard-false-positives-in-linux-kernel/">PowerPC stack guard false positives in Linux kernel</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/rcu-and-dynticks-idle-mode/">RCU and dynticks-idle mode</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/rcu-preempt-what-happens-on-a-context-switch/">RCU-preempt: What happens on a context switch</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/resources/">Resources</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/selinux-debugging-on-chromeos/">SELinux Debugging on ChromeOS</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/single-stepping-the-kernels-c-code/">Single-stepping the kernel&#39;s C code</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/srcu-state-double-scan/">SRCU state double scan</a>
      </li>
    
      <li class="post">
        <a href="http://localhost:1313/blog/1/01/01/understanding-hazard-pointers/">Understanding Hazard Pointers</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>About Me</h1>
  <p>A little something about me.</p>
</section>
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2025 - Joel Fernandes -
  <span class="credit">Powered by <a href="https://gohugo.io">Hugo</a></span>
</p></footer>
  
</body>
</html>