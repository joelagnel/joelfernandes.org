
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>JoelFernandes.org</title>
  <meta name="author" content="Joel Fernandes">

  
  <meta name="description" content="

  
  rcu_sync: For Scalable alteration of execution paths
The Linux kernel has a number of places that involve a slow path and a fast
path for an...">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.linuxinternals.org/rcu-sync/article.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="" rel="alternate" title="JoelFernandes.org" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-50777115-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-50777115-1');
</script>

</head>

<body   class="no-sidebar"  >
  <header role="banner"><div>
<div style="margin-right:50px;float:left;">
  <h1><a href="/">JoelFernandes.org</a></h1>
  
  <!--
    1/29/2023:
    Changed from h2 to h6 to accomodate longer subtitle.
  -->
    <h6>Age is of no importance unless you're a cheese -- Billie Burke</h6>
  
</div>
<div style="float:left;" class="hnav">
 <br>
 <!--
   a href="/linuxinternals/">Linux Internals Articles</a><br>
 !-->
 <a href="/categories/">Posts by category</a><br>
 <a href="/blog/archives/">Archive of all posts</a><br>
 <a href="/resources">Presentations and other work.</a><br>
</div>
<div style="float:right;">
<img src="/images/peng.png" height=100 width=100>
</div>
</div>

</header>
<!--
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:http://www.linuxinternals.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/technical-resources/">Resources</a></li>
  <li><a href="/aboutme/">About me</a></li>
</ul>

</nav>
-->
  <div id="main">
    <div id="content">
      <div>
<article role="article">
  
  <h1 id="rcu_sync-for-scalable-alteration-of-execution-paths">rcu_sync: For Scalable alteration of execution paths</h1>
<p>The Linux kernel has a number of places that involve a slow path and a fast
path for an operation. Fast path executes a lot more often, while the slow path
is left for the rare cases. This split design can improve performance.</p>

<p>One such example of this pattern is the percpu-rwsem locking primitive. This
locking primitive is designed for use cases where a tradition reader-writer
semaphore (rwsem) still does not scale. A rwsem does not incur any lock
contention when there are only readers involved, as multiple readers are
allowed to execute their critical section concurrently. However, it does incur
cache contention because each CPU has to exclusively gain access to exclusive
access to the cache line containing the lock. This cause L1 cacheline bouncing
among the reader CPUs. percpu-rwsem solves this problem by making using a
per-cpu counter for each CPU.</p>

<p>A percpu-rwsem structure looks like:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct percpu_rw_semaphore {
        struct rcu_sync         rss;
        unsigned int __percpu   *read_count;
        struct rw_semaphore     rw_sem;
        struct rcuwait          writer;
        int                     readers_block;
};
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">read_count</code> element is a percpu counter keeping track of how many readers
are currently in their reader section.</p>

<h2 id="the-fast-path">The fast path</h2>
<p>In the common case, where no writers are involved and a reader tries to acquire
the lock, all it needs to is increment its per-cpu <code class="language-plaintext highlighter-rouge">read_count</code> variable, and
enter the reader section. This involves no cacheline bouncing or contention
thus solving the first problem discussed (about L1 cacheline bouncing).</p>

<h2 id="the-slow-path">The slow path</h2>
<p>If there is already a ‘writer’ that acquired the lock however, then the reader
must enter the slow path in order to acquire the lock. The slow path involves
acquiring a traditional reader-writer semaphore (rw_sem) in the
<code class="language-plaintext highlighter-rouge">percpu_rw_semaphore</code> object. Note that a writer acquiring the
<code class="language-plaintext highlighter-rouge">percpu_rw_sempahore</code> implies that it has also already acquired the traditional
reader-writer semaphore (rw_sem) as well. Because of this the reader will block
and be awakened later once the writer releases the rw_sem.</p>

<h2 id="how-does-the-reader-switch-between-fast-and-slow-paths">How does the reader switch between fast and slow paths?</h2>
<p>Before a writer acquires a lock, it must notify readers that they must now
switch to their slow paths. This notification is done using the <code class="language-plaintext highlighter-rouge">readers_block</code>
flag in <code class="language-plaintext highlighter-rouge">percpu_rw_sempahore</code>.</p>

<p>One way to achieve this notification is: A writer atomically update <code class="language-plaintext highlighter-rouge">readers_block</code>.
flag. Readers then atomically read <code class="language-plaintext highlighter-rouge">readers_block</code> and make note that they must
now enter their slow paths to acquire the lock.  Atomic reads are expensive
though and would defeat the scalability goals mentioned earlier.</p>

<p>Another way to achieve this synchronization between readers and writers, is
using the kernel’s rcu-sync framework. The <code class="language-plaintext highlighter-rouge">rss</code> element in
<code class="language-plaintext highlighter-rouge">percpu_rw_semaphore</code> is used for the purposes of this.</p>

<p>When a writer wants the readers to enter their slow path, it sets some state in
the <code class="language-plaintext highlighter-rouge">rss</code> element. For simplicity, let us assume that if the state is 1, then
the reader must enter their slow path and if the state is 0, then a reader must
enter its fast path.</p>

<p>When a reader checks this state, it must do so only inside an RCU reader
section. This is achieved by just disabling preemption during the read access.</p>

<p>Once the writer changes the state to 1, it waits for a grace period. At the end
of this grace period, the writer knows for sure that any future readers after
this point, will only enter their slow paths.</p>

<p>However, some readers might have already entered their fast paths. Before
entering its critical section, the writer must ensure that there are no readers
active (readers and writers are mutually exclusive in a reader-writer
sempahore). To do this, it first acquires the internal <code class="language-plaintext highlighter-rouge">rwsem</code> and then scans
the per-cpu <code class="language-plaintext highlighter-rouge">read_count</code> variable and ensures they are all 0.</p>

<p>Quiz:
What if a reader has noticed that state is 0 and thinks that it needs to enter
the fast path, but has not yet incremented the <code class="language-plaintext highlighter-rouge">read_count</code>? Will the writer
falsely think that there are no more readers active and enter its critical section?
Ans:
This cannot happen because in the slow path, the reader’s increment of
<code class="language-plaintext highlighter-rouge">read_count</code> actually happens while the internal <code class="language-plaintext highlighter-rouge">rw_sem</code> is held. Since the
writer acquires the internal rwsem right after the grace period, the reader’s
update of the <code class="language-plaintext highlighter-rouge">read_count</code> will block until the writer releases the <code class="language-plaintext highlighter-rouge">rw_sem</code> in
the unlock path.</p>

<h2 id="performance-of-rwsem-vs-percpu-rwsem">Performance of rwsem vs percpu-rwsem</h2>
<p>The following test shows the scalability of percpu-rwsem. The test spawns a
set of threads that do a lock/unlock 10,000 times and measures the total time
duration of the test. As shown below, as the number of threads increase, the
total time taken by an rwsem increases linearly, with the time taken by
percpu-rwsem remaining at a constant.</p>

<p><img src="percpu-rwsem-test.png" alt="percpu-rwsem-test" /></p>

  
</article>

</div>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2023 - Joel Fernandes -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
